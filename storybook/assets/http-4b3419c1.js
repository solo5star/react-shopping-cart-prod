import{R as Z}from"./index-8db94870.js";import{R as Er}from"./index-8ce4a492.js";function Ar(e){const t=new Error(e);if(t.stack===void 0)try{throw t}catch{}return t}var Nr=Ar,I=Nr;function Lr(e){return!!e&&typeof e.then=="function"}var G=Lr;function Cr(e,t){if(e!=null)return e;throw I(t??"Got unexpected null or undefined")}var q=Cr;function M(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}class gt{getValue(){throw I("BaseLoadable")}toPromise(){throw I("BaseLoadable")}valueMaybe(){throw I("BaseLoadable")}valueOrThrow(){throw I(`Loadable expected value, but in "${this.state}" state`)}promiseMaybe(){throw I("BaseLoadable")}promiseOrThrow(){throw I(`Loadable expected promise, but in "${this.state}" state`)}errorMaybe(){throw I("BaseLoadable")}errorOrThrow(){throw I(`Loadable expected error, but in "${this.state}" state`)}is(t){return t.state===this.state&&t.contents===this.contents}map(t){throw I("BaseLoadable")}}class Vr extends gt{constructor(t){super(),M(this,"state","hasValue"),M(this,"contents",void 0),this.contents=t}getValue(){return this.contents}toPromise(){return Promise.resolve(this.contents)}valueMaybe(){return this.contents}valueOrThrow(){return this.contents}promiseMaybe(){}errorMaybe(){}map(t){try{const n=t(this.contents);return G(n)?Le(n):Oe(n)?n:ot(n)}catch(n){return G(n)?Le(n.next(()=>this.map(t))):bt(n)}}}class $r extends gt{constructor(t){super(),M(this,"state","hasError"),M(this,"contents",void 0),this.contents=t}getValue(){throw this.contents}toPromise(){return Promise.reject(this.contents)}valueMaybe(){}promiseMaybe(){}errorMaybe(){return this.contents}errorOrThrow(){return this.contents}map(t){return this}}class Yn extends gt{constructor(t){super(),M(this,"state","loading"),M(this,"contents",void 0),this.contents=t}getValue(){throw this.contents}toPromise(){return this.contents}valueMaybe(){}promiseMaybe(){return this.contents}promiseOrThrow(){return this.contents}errorMaybe(){}map(t){return Le(this.contents.then(n=>{const o=t(n);if(Oe(o)){const r=o;switch(r.state){case"hasValue":return r.contents;case"hasError":throw r.contents;case"loading":return r.contents}}return o}).catch(n=>{if(G(n))return n.then(()=>this.map(t).contents);throw n}))}}function ot(e){return Object.freeze(new Vr(e))}function bt(e){return Object.freeze(new $r(e))}function Le(e){return Object.freeze(new Yn(e))}function Xn(){return Object.freeze(new Yn(new Promise(()=>{})))}function Mr(e){return e.every(t=>t.state==="hasValue")?ot(e.map(t=>t.contents)):e.some(t=>t.state==="hasError")?bt(q(e.find(t=>t.state==="hasError"),"Invalid loadable passed to loadableAll").contents):Le(Promise.all(e.map(t=>t.contents)))}function Jn(e){const n=(Array.isArray(e)?e:Object.getOwnPropertyNames(e).map(r=>e[r])).map(r=>Oe(r)?r:G(r)?Le(r):ot(r)),o=Mr(n);return Array.isArray(e)?o:o.map(r=>Object.getOwnPropertyNames(e).reduce((a,s,l)=>({...a,[s]:r[l]}),{}))}function Oe(e){return e instanceof gt}const Ir={of:e=>G(e)?Le(e):Oe(e)?e:ot(e),error:e=>bt(e),loading:()=>Xn(),all:Jn,isLoadable:Oe};var Ve={loadableWithValue:ot,loadableWithError:bt,loadableWithPromise:Le,loadableLoading:Xn,loadableAll:Jn,isLoadable:Oe,RecoilLoadable:Ir},Ur=Ve.loadableWithValue,kr=Ve.loadableWithError,Dr=Ve.loadableWithPromise,Br=Ve.loadableLoading,Pr=Ve.loadableAll,Or=Ve.isLoadable,xr=Ve.RecoilLoadable,rt=Object.freeze({__proto__:null,loadableWithValue:Ur,loadableWithError:kr,loadableWithPromise:Dr,loadableLoading:Br,loadableAll:Pr,isLoadable:Or,RecoilLoadable:xr});const Jt={RECOIL_DUPLICATE_ATOM_KEY_CHECKING_ENABLED:!0,RECOIL_GKS_ENABLED:new Set(["recoil_hamt_2020","recoil_sync_external_store","recoil_suppress_rerender_in_callback","recoil_memory_managament_2020"])};function Fr(e,t){var n,o;const r=(n=process.env[e])===null||n===void 0||(o=n.toLowerCase())===null||o===void 0?void 0:o.trim();if(r==null||r==="")return;if(!["true","false"].includes(r))throw I(`({}).${e} value must be 'true', 'false', or empty: ${r}`);t(r==="true")}function zr(e,t){var n;const o=(n=process.env[e])===null||n===void 0?void 0:n.trim();o==null||o===""||t(o.split(/\s*,\s*|\s+/))}function Wr(){var e;typeof process>"u"||((e=process)===null||e===void 0?void 0:e.env)!=null&&(Fr("RECOIL_DUPLICATE_ATOM_KEY_CHECKING_ENABLED",t=>{Jt.RECOIL_DUPLICATE_ATOM_KEY_CHECKING_ENABLED=t}),zr("RECOIL_GKS_ENABLED",t=>{t.forEach(n=>{Jt.RECOIL_GKS_ENABLED.add(n)})}))}Wr();var Ge=Jt;function Tt(e){return Ge.RECOIL_GKS_ENABLED.has(e)}Tt.setPass=e=>{Ge.RECOIL_GKS_ENABLED.add(e)};Tt.setFail=e=>{Ge.RECOIL_GKS_ENABLED.delete(e)};Tt.clear=()=>{Ge.RECOIL_GKS_ENABLED.clear()};var W=Tt;function Gr(e,t,{error:n}={}){return null}var Kr=Gr,cn=Kr,Gt,Kt,Ht;const Hr=(Gt=Z.createMutableSource)!==null&&Gt!==void 0?Gt:Z.unstable_createMutableSource,Qn=(Kt=Z.useMutableSource)!==null&&Kt!==void 0?Kt:Z.unstable_useMutableSource,eo=(Ht=Z.useSyncExternalStore)!==null&&Ht!==void 0?Ht:Z.unstable_useSyncExternalStore;function jr(){var e;const{ReactCurrentDispatcher:t,ReactCurrentOwner:n}=Z.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;return((e=t==null?void 0:t.current)!==null&&e!==void 0?e:n.currentDispatcher).useSyncExternalStore!=null}function qr(){return W("recoil_transition_support")?{mode:"TRANSITION_SUPPORT",early:!0,concurrent:!0}:W("recoil_sync_external_store")&&eo!=null?{mode:"SYNC_EXTERNAL_STORE",early:!0,concurrent:!1}:W("recoil_mutable_source")&&Qn!=null&&typeof window<"u"&&!window.$disableRecoilValueMutableSource_TEMP_HACK_DO_NOT_USE?W("recoil_suppress_rerender_in_callback")?{mode:"MUTABLE_SOURCE",early:!0,concurrent:!0}:{mode:"MUTABLE_SOURCE",early:!1,concurrent:!1}:W("recoil_suppress_rerender_in_callback")?{mode:"LEGACY",early:!0,concurrent:!1}:{mode:"LEGACY",early:!1,concurrent:!1}}function Zr(){return!1}var at={createMutableSource:Hr,useMutableSource:Qn,useSyncExternalStore:eo,currentRendererSupportsUseSyncExternalStore:jr,reactMode:qr,isFastRefreshEnabled:Zr};class ln{constructor(t){M(this,"key",void 0),this.key=t}toJSON(){return{key:this.key}}}class to extends ln{}class no extends ln{}function Yr(e){return e instanceof to||e instanceof no}var wt={AbstractRecoilValue:ln,RecoilState:to,RecoilValueReadOnly:no,isRecoilValue:Yr},Xr=wt.AbstractRecoilValue,Jr=wt.RecoilState,Qr=wt.RecoilValueReadOnly,ea=wt.isRecoilValue,xe=Object.freeze({__proto__:null,AbstractRecoilValue:Xr,RecoilState:Jr,RecoilValueReadOnly:Qr,isRecoilValue:ea});function ta(e,t){return function*(){let n=0;for(const o of e)yield t(o,n++)}()}var Et=ta;class oo{}const na=new oo,Ce=new Map,un=new Map;function oa(e){return Et(e,t=>q(un.get(t)))}function ra(e){if(Ce.has(e)){const t=`Duplicate atom key "${e}". This is a FATAL ERROR in
      production. But it is safe to ignore this warning if it occurred because of
      hot module replacement.`;console.warn(t)}}function aa(e){Ge.RECOIL_DUPLICATE_ATOM_KEY_CHECKING_ENABLED&&ra(e.key),Ce.set(e.key,e);const t=e.set==null?new xe.RecoilValueReadOnly(e.key):new xe.RecoilState(e.key);return un.set(e.key,t),t}class ro extends Error{}function sa(e){const t=Ce.get(e);if(t==null)throw new ro(`Missing definition for RecoilValue: "${e}""`);return t}function ia(e){return Ce.get(e)}const St=new Map;function ca(e){var t;if(!W("recoil_memory_managament_2020"))return;const n=Ce.get(e);if(n!=null&&(t=n.shouldDeleteConfigOnRelease)!==null&&t!==void 0&&t.call(n)){var o;Ce.delete(e),(o=ao(e))===null||o===void 0||o(),St.delete(e)}}function la(e,t){W("recoil_memory_managament_2020")&&(t===void 0?St.delete(e):St.set(e,t))}function ao(e){return St.get(e)}var ce={nodes:Ce,recoilValues:un,registerNode:aa,getNode:sa,getNodeMaybe:ia,deleteNodeConfigIfPossible:ca,setConfigDeletionHandler:la,getConfigDeletionHandler:ao,recoilValuesForKeys:oa,NodeMissingError:ro,DefaultValue:oo,DEFAULT_VALUE:na};function ua(e,t){t()}var da={enqueueExecution:ua};function fa(e,t){return t={exports:{}},e(t,t.exports),t.exports}var ha=fa(function(e){var t=typeof Symbol=="function"&&typeof Symbol.iterator=="symbol"?function(c){return typeof c}:function(c){return c&&typeof Symbol=="function"&&c.constructor===Symbol&&c!==Symbol.prototype?"symbol":typeof c},n={},o=5,r=Math.pow(2,o),a=r-1,s=r/2,l=r/4,u={},f=function(i){return function(){return i}},v=n.hash=function(c){var i=typeof c>"u"?"undefined":t(c);if(i==="number")return c;i!=="string"&&(c+="");for(var h=0,m=0,R=c.length;m<R;++m){var g=c.charCodeAt(m);h=(h<<5)-h+g|0}return h},_=function(i){return i-=i>>1&1431655765,i=(i&858993459)+(i>>2&858993459),i=i+(i>>4)&252645135,i+=i>>8,i+=i>>16,i&127},V=function(i,h){return h>>>i&a},C=function(i){return 1<<i},y=function(i,h){return _(i&h-1)},E=function(i,h,m,R){var g=R;if(!i){var L=R.length;g=new Array(L);for(var A=0;A<L;++A)g[A]=R[A]}return g[h]=m,g},Y=function(i,h,m){var R=m.length-1,g=0,L=0,A=m;if(i)g=L=h;else for(A=new Array(R);g<h;)A[L++]=m[g++];for(++g;g<=R;)A[L++]=m[g++];return i&&(A.length=R),A},te=function(i,h,m,R){var g=R.length;if(i){for(var L=g;L>=h;)R[L--]=R[L];return R[h]=m,R}for(var A=0,N=0,U=new Array(g+1);A<h;)U[N++]=R[A++];for(U[h]=m;A<g;)U[++N]=R[A++];return U},w=1,B=2,Q=3,z=4,K={__hamt_isEmpty:!0},X=function(i){return i===K||i&&i.__hamt_isEmpty},ae=function(i,h,m,R){return{type:w,edit:i,hash:h,key:m,value:R,_modify:Ue}},me=function(i,h,m){return{type:B,edit:i,hash:h,children:m,_modify:ke}},x=function(i,h,m){return{type:Q,edit:i,mask:h,children:m,_modify:P}},re=function(i,h,m){return{type:z,edit:i,size:h,children:m,_modify:O}},Ee=function(i){return i===K||i.type===w||i.type===B},oe=function(i,h,m,R,g){for(var L=[],A=R,N=0,U=0;A;++U)A&1&&(L[U]=g[N++]),A>>>=1;return L[h]=m,re(i,N+1,L)},le=function(i,h,m,R){for(var g=new Array(h-1),L=0,A=0,N=0,U=R.length;N<U;++N)if(N!==m){var j=R[N];j&&!X(j)&&(g[L++]=j,A|=1<<N)}return x(i,A,g)},Me=function c(i,h,m,R,g,L){if(m===g)return me(i,m,[L,R]);var A=V(h,m),N=V(h,g);return x(i,C(A)|C(N),A===N?[c(i,h+o,m,R,g,L)]:A<N?[R,L]:[L,R])},Ie=function(i,h,m,R,g,L,A,N){for(var U=g.length,j=0;j<U;++j){var se=g[j];if(m(A,se.key)){var ne=se.value,fe=L(ne);return fe===ne?g:fe===u?(--N.value,Y(i,j,g)):E(i,j,ae(h,R,A,fe),g)}}var ve=L();return ve===u?g:(++N.value,E(i,U,ae(h,R,A,ve),g))},Re=function(i,h){return i===h.edit},Ue=function(i,h,m,R,g,L,A){if(h(L,this.key)){var N=R(this.value);return N===this.value?this:N===u?(--A.value,K):Re(i,this)?(this.value=N,this):ae(i,g,L,N)}var U=R();return U===u?this:(++A.value,Me(i,m,this.hash,this,g,ae(i,g,L,U)))},ke=function(i,h,m,R,g,L,A){if(g===this.hash){var N=Re(i,this),U=Ie(N,i,h,this.hash,this.children,R,L,A);return U===this.children?this:U.length>1?me(i,this.hash,U):U[0]}var j=R();return j===u?this:(++A.value,Me(i,m,this.hash,this,g,ae(i,g,L,j)))},P=function(i,h,m,R,g,L,A){var N=this.mask,U=this.children,j=V(m,g),se=C(j),ne=y(N,se),fe=N&se,ve=fe?U[ne]:K,De=ve._modify(i,h,m+o,R,g,L,A);if(ve===De)return this;var ut=Re(i,this),He=N,je=void 0;if(fe&&X(De)){if(He&=~se,!He)return K;if(U.length<=2&&Ee(U[ne^1]))return U[ne^1];je=Y(ut,ne,U)}else if(!fe&&!X(De)){if(U.length>=s)return oe(i,j,De,N,U);He|=se,je=te(ut,ne,De,U)}else je=E(ut,ne,De,U);return ut?(this.mask=He,this.children=je,this):x(i,He,je)},O=function(i,h,m,R,g,L,A){var N=this.size,U=this.children,j=V(m,g),se=U[j],ne=(se||K)._modify(i,h,m+o,R,g,L,A);if(se===ne)return this;var fe=Re(i,this),ve=void 0;if(X(se)&&!X(ne))++N,ve=E(fe,j,ne,U);else if(!X(se)&&X(ne)){if(--N,N<=l)return le(i,N,j,U);ve=E(fe,j,K,U)}else ve=E(fe,j,ne,U);return fe?(this.size=N,this.children=ve,this):re(i,N,ve)};K._modify=function(c,i,h,m,R,g,L){var A=m();return A===u?K:(++L.value,ae(c,R,g,A))};function d(c,i,h,m,R){this._editable=c,this._edit=i,this._config=h,this._root=m,this._size=R}d.prototype.setTree=function(c,i){return this._editable?(this._root=c,this._size=i,this):c===this._root?this:new d(this._editable,this._edit,this._config,c,i)};var p=n.tryGetHash=function(c,i,h,m){for(var R=m._root,g=0,L=m._config.keyEq;;)switch(R.type){case w:return L(h,R.key)?R.value:c;case B:{if(i===R.hash)for(var A=R.children,N=0,U=A.length;N<U;++N){var j=A[N];if(L(h,j.key))return j.value}return c}case Q:{var se=V(g,i),ne=C(se);if(R.mask&ne){R=R.children[y(R.mask,ne)],g+=o;break}return c}case z:{if(R=R.children[V(g,i)],R){g+=o;break}return c}default:return c}};d.prototype.tryGetHash=function(c,i,h){return p(c,i,h,this)};var S=n.tryGet=function(c,i,h){return p(c,h._config.hash(i),i,h)};d.prototype.tryGet=function(c,i){return S(c,i,this)};var $=n.getHash=function(c,i,h){return p(void 0,c,i,h)};d.prototype.getHash=function(c,i){return $(c,i,this)},n.get=function(c,i){return p(void 0,i._config.hash(c),c,i)},d.prototype.get=function(c,i){return S(i,c,this)};var b=n.has=function(c,i,h){return p(u,c,i,h)!==u};d.prototype.hasHash=function(c,i){return b(c,i,this)};var D=n.has=function(c,i){return b(i._config.hash(c),c,i)};d.prototype.has=function(c){return D(c,this)};var k=function(i,h){return i===h};n.make=function(c){return new d(0,0,{keyEq:c&&c.keyEq||k,hash:c&&c.hash||v},K,0)},n.empty=n.make();var T=n.isEmpty=function(c){return c&&!!X(c._root)};d.prototype.isEmpty=function(){return T(this)};var H=n.modifyHash=function(c,i,h,m){var R={value:m._size},g=m._root._modify(m._editable?m._edit:NaN,m._config.keyEq,0,c,i,h,R);return m.setTree(g,R.value)};d.prototype.modifyHash=function(c,i,h){return H(h,c,i,this)};var ee=n.modify=function(c,i,h){return H(c,h._config.hash(i),i,h)};d.prototype.modify=function(c,i){return ee(i,c,this)};var F=n.setHash=function(c,i,h,m){return H(f(h),c,i,m)};d.prototype.setHash=function(c,i,h){return F(c,i,h,this)};var J=n.set=function(c,i,h){return F(h._config.hash(c),c,i,h)};d.prototype.set=function(c,i){return J(c,i,this)};var he=f(u),Ae=n.removeHash=function(c,i,h){return H(he,c,i,h)};d.prototype.removeHash=d.prototype.deleteHash=function(c,i){return Ae(c,i,this)};var de=n.remove=function(c,i){return Ae(i._config.hash(c),c,i)};d.prototype.remove=d.prototype.delete=function(c){return de(c,this)};var ue=n.beginMutation=function(c){return new d(c._editable+1,c._edit+1,c._config,c._root,c._size)};d.prototype.beginMutation=function(){return ue(this)};var wn=n.endMutation=function(c){return c._editable=c._editable&&c._editable-1,c};d.prototype.endMutation=function(){return wn(this)};var pr=n.mutate=function(c,i){var h=ue(i);return c(h),wn(h)};d.prototype.mutate=function(c){return pr(c,this)};var Ft=function(i){return i&&En(i[0],i[1],i[2],i[3],i[4])},En=function(i,h,m,R,g){for(;m<i;){var L=h[m++];if(L&&!X(L))return An(L,R,[i,h,m,R,g])}return Ft(g)},An=function(i,h,m){switch(i.type){case w:return{value:h(i),rest:m};case B:case z:case Q:var R=i.children;return En(R.length,R,0,h,m);default:return Ft(m)}},_r={done:!0};function zt(c){this.v=c}zt.prototype.next=function(){if(!this.v)return _r;var c=this.v;return this.v=Ft(c.rest),c},zt.prototype[Symbol.iterator]=function(){return this};var Wt=function(i,h){return new zt(An(i._root,h))},Sr=function(i){return[i.key,i.value]},mr=n.entries=function(c){return Wt(c,Sr)};d.prototype.entries=d.prototype[Symbol.iterator]=function(){return mr(this)};var Rr=function(i){return i.key},yr=n.keys=function(c){return Wt(c,Rr)};d.prototype.keys=function(){return yr(this)};var gr=function(i){return i.value},br=n.values=d.prototype.values=function(c){return Wt(c,gr)};d.prototype.values=function(){return br(this)};var Nn=n.fold=function(c,i,h){var m=h._root;if(m.type===w)return c(i,m.value,m.key);for(var R=[m.children],g=void 0;g=R.pop();)for(var L=0,A=g.length;L<A;){var N=g[L++];N&&N.type&&(N.type===w?i=c(i,N.value,N.key):R.push(N.children))}return i};d.prototype.fold=function(c,i){return Nn(c,i,this)};var Tr=n.forEach=function(c,i){return Nn(function(h,m,R){return c(m,R,i)},null,i)};d.prototype.forEach=function(c){return Tr(c,this)};var wr=n.count=function(c){return c._size};d.prototype.count=function(){return wr(this)},Object.defineProperty(d.prototype,"size",{get:d.prototype.count}),e.exports?e.exports=n:(void 0).hamt=n});class va{constructor(t){M(this,"_map",void 0),this._map=new Map(t==null?void 0:t.entries())}keys(){return this._map.keys()}entries(){return this._map.entries()}get(t){return this._map.get(t)}has(t){return this._map.has(t)}set(t,n){return this._map.set(t,n),this}delete(t){return this._map.delete(t),this}clone(){return fn(this)}toMap(){return new Map(this._map)}}class dn{constructor(t){if(M(this,"_hamt",ha.empty.beginMutation()),t instanceof dn){const n=t._hamt.endMutation();t._hamt=n.beginMutation(),this._hamt=n.beginMutation()}else if(t)for(const[n,o]of t.entries())this._hamt.set(n,o)}keys(){return this._hamt.keys()}entries(){return this._hamt.entries()}get(t){return this._hamt.get(t)}has(t){return this._hamt.has(t)}set(t,n){return this._hamt.set(t,n),this}delete(t){return this._hamt.delete(t),this}clone(){return fn(this)}toMap(){return new Map(this._hamt)}}function fn(e){return W("recoil_hamt_2020")?new dn(e):new va(e)}var pa={persistentMap:fn},_a=pa.persistentMap,Sa=Object.freeze({__proto__:null,persistentMap:_a});function ma(e,...t){const n=new Set;e:for(const o of e){for(const r of t)if(r.has(o))continue e;n.add(o)}return n}var et=ma;function Ra(e,t){const n=new Map;return e.forEach((o,r)=>{n.set(r,t(o,r))}),n}var mt=Ra;function ya(){return{nodeDeps:new Map,nodeToNodeSubscriptions:new Map}}function ga(e){return{nodeDeps:mt(e.nodeDeps,t=>new Set(t)),nodeToNodeSubscriptions:mt(e.nodeToNodeSubscriptions,t=>new Set(t))}}function jt(e,t,n,o){const{nodeDeps:r,nodeToNodeSubscriptions:a}=n,s=r.get(e);if(s&&o&&s!==o.nodeDeps.get(e))return;r.set(e,t);const l=s==null?t:et(t,s);for(const u of l)a.has(u)||a.set(u,new Set),q(a.get(u)).add(e);if(s){const u=et(s,t);for(const f of u){if(!a.has(f))return;const v=q(a.get(f));v.delete(e),v.size===0&&a.delete(f)}}}function ba(e,t,n,o){var r,a,s,l;const u=n.getState();o===u.currentTree.version||o===((r=u.nextTree)===null||r===void 0?void 0:r.version)||((a=u.previousTree)===null||a===void 0||a.version);const f=n.getGraph(o);if(jt(e,t,f),o===((s=u.previousTree)===null||s===void 0?void 0:s.version)){const _=n.getGraph(u.currentTree.version);jt(e,t,_,f)}if(o===((l=u.previousTree)===null||l===void 0?void 0:l.version)||o===u.currentTree.version){var v;const _=(v=u.nextTree)===null||v===void 0?void 0:v.version;if(_!==void 0){const V=n.getGraph(_);jt(e,t,V,f)}}}var st={cloneGraph:ga,graph:ya,saveDepsToStore:ba};let Ta=0;const wa=()=>Ta++;let Ea=0;const Aa=()=>Ea++;let Na=0;const La=()=>Na++;var At={getNextTreeStateVersion:wa,getNextStoreID:Aa,getNextComponentID:La};const{persistentMap:Ln}=Sa,{graph:Ca}=st,{getNextTreeStateVersion:so}=At;function io(){const e=so();return{version:e,stateID:e,transactionMetadata:{},dirtyAtoms:new Set,atomValues:Ln(),nonvalidatedAtoms:Ln()}}function Va(){const e=io();return{currentTree:e,nextTree:null,previousTree:null,commitDepth:0,knownAtoms:new Set,knownSelectors:new Set,transactionSubscriptions:new Map,nodeTransactionSubscriptions:new Map,nodeToComponentSubscriptions:new Map,queuedComponentCallbacks_DEPRECATED:[],suspendedComponentResolvers:new Set,graphsByVersion:new Map().set(e.version,Ca()),retention:{referenceCounts:new Map,nodesRetainedByZone:new Map,retainablesToCheckForRelease:new Set},nodeCleanupFunctions:new Map}}var co={makeEmptyTreeState:io,makeEmptyStoreState:Va,getNextTreeStateVersion:so};class lo{}function $a(){return new lo}var Nt={RetentionZone:lo,retentionZone:$a};function Ma(e,t){const n=new Set(e);return n.add(t),n}function Ia(e,t){const n=new Set(e);return n.delete(t),n}function Ua(e,t,n){const o=new Map(e);return o.set(t,n),o}function ka(e,t,n){const o=new Map(e);return o.set(t,n(o.get(t))),o}function Da(e,t){const n=new Map(e);return n.delete(t),n}function Ba(e,t){const n=new Map(e);return t.forEach(o=>n.delete(o)),n}var uo={setByAddingToSet:Ma,setByDeletingFromSet:Ia,mapBySettingInMap:Ua,mapByUpdatingInMap:ka,mapByDeletingFromMap:Da,mapByDeletingMultipleFromMap:Ba};function*Pa(e,t){let n=0;for(const o of e)t(o,n++)&&(yield o)}var hn=Pa;function Oa(e,t){return new Proxy(e,{get:(o,r)=>(!(r in o)&&r in t&&(o[r]=t[r]()),o[r]),ownKeys:o=>Object.keys(o)})}var fo=Oa;const{getNode:it,getNodeMaybe:xa,recoilValuesForKeys:Cn}=ce,{RetentionZone:Vn}=Nt,{setByAddingToSet:Fa}=uo,za=Object.freeze(new Set);class Wa extends Error{}function Ga(e,t,n){if(!W("recoil_memory_managament_2020"))return()=>{};const{nodesRetainedByZone:o}=e.getState().retention;function r(a){let s=o.get(a);s||o.set(a,s=new Set),s.add(t)}if(n instanceof Vn)r(n);else if(Array.isArray(n))for(const a of n)r(a);return()=>{if(!W("recoil_memory_managament_2020"))return;const{retention:a}=e.getState();function s(l){const u=a.nodesRetainedByZone.get(l);u==null||u.delete(t),u&&u.size===0&&a.nodesRetainedByZone.delete(l)}if(n instanceof Vn)s(n);else if(Array.isArray(n))for(const l of n)s(l)}}function vn(e,t,n,o){const r=e.getState();if(r.nodeCleanupFunctions.has(n))return;const a=it(n),s=Ga(e,n,a.retainedBy),l=a.init(e,t,o);r.nodeCleanupFunctions.set(n,()=>{l(),s()})}function Ka(e,t,n){vn(e,e.getState().currentTree,t,n)}function Ha(e,t){var n;const o=e.getState();(n=o.nodeCleanupFunctions.get(t))===null||n===void 0||n(),o.nodeCleanupFunctions.delete(t)}function ja(e,t,n){return vn(e,t,n,"get"),it(n).get(e,t)}function ho(e,t,n){return it(n).peek(e,t)}function qa(e,t,n){var o;const r=xa(t);return r==null||(o=r.invalidate)===null||o===void 0||o.call(r,e),{...e,atomValues:e.atomValues.clone().delete(t),nonvalidatedAtoms:e.nonvalidatedAtoms.clone().set(t,n),dirtyAtoms:Fa(e.dirtyAtoms,t)}}function Za(e,t,n,o){const r=it(n);if(r.set==null)throw new Wa(`Attempt to set read-only RecoilValue: ${n}`);const a=r.set;return vn(e,t,n,"set"),a(e,t,o)}function Ya(e,t,n){const o=e.getState(),r=e.getGraph(t.version),a=it(n).nodeType;return fo({type:a},{loadable:()=>ho(e,t,n),isActive:()=>o.knownAtoms.has(n)||o.knownSelectors.has(n),isSet:()=>a==="selector"?!1:t.atomValues.has(n),isModified:()=>t.dirtyAtoms.has(n),deps:()=>{var s;return Cn((s=r.nodeDeps.get(n))!==null&&s!==void 0?s:[])},subscribers:()=>{var s,l;return{nodes:Cn(hn(vo(e,t,new Set([n])),u=>u!==n)),components:Et((s=(l=o.nodeToComponentSubscriptions.get(n))===null||l===void 0?void 0:l.values())!==null&&s!==void 0?s:[],([u])=>({name:u}))}}})}function vo(e,t,n){const o=new Set,r=Array.from(n),a=e.getGraph(t.version);for(let l=r.pop();l;l=r.pop()){var s;o.add(l);const u=(s=a.nodeToNodeSubscriptions.get(l))!==null&&s!==void 0?s:za;for(const f of u)o.has(f)||r.push(f)}return o}var Te={getNodeLoadable:ja,peekNodeLoadable:ho,setNodeValue:Za,initializeNode:Ka,cleanUpNode:Ha,setUnvalidatedAtomValue_DEPRECATED:qa,peekNodeInfo:Ya,getDownstreamNodes:vo};let po=null;function Xa(e){po=e}function Ja(){var e;(e=po)===null||e===void 0||e()}var _o={setInvalidateMemoizedSnapshot:Xa,invalidateMemoizedSnapshot:Ja};const{getDownstreamNodes:Qa,getNodeLoadable:So,setNodeValue:es}=Te,{getNextComponentID:ts}=At,{getNode:ns,getNodeMaybe:mo}=ce,{DefaultValue:pn}=ce,{reactMode:os}=at,{AbstractRecoilValue:rs,RecoilState:as,RecoilValueReadOnly:ss,isRecoilValue:is}=xe,{invalidateMemoizedSnapshot:cs}=_o;function ls(e,{key:t},n=e.getState().currentTree){var o,r;const a=e.getState();n.version===a.currentTree.version||n.version===((o=a.nextTree)===null||o===void 0?void 0:o.version)||(n.version,(r=a.previousTree)===null||r===void 0||r.version);const s=So(e,n,t);return s.state==="loading"&&s.contents.catch(()=>{}),s}function us(e,t){const n=e.clone();return t.forEach((o,r)=>{o.state==="hasValue"&&o.contents instanceof pn?n.delete(r):n.set(r,o)}),n}function ds(e,t,{key:n},o){if(typeof o=="function"){const r=So(e,t,n);if(r.state==="loading"){const a=`Tried to set atom or selector "${n}" using an updater function while the current state is pending, this is not currently supported.`;throw I(a)}else if(r.state==="hasError")throw r.contents;return o(r.contents)}else return o}function fs(e,t,n){if(n.type==="set"){const{recoilValue:r,valueOrUpdater:a}=n,s=ds(e,t,r,a),l=es(e,t,r.key,s);for(const[u,f]of l.entries())Qt(t,u,f)}else if(n.type==="setLoadable"){const{recoilValue:{key:r},loadable:a}=n;Qt(t,r,a)}else if(n.type==="markModified"){const{recoilValue:{key:r}}=n;t.dirtyAtoms.add(r)}else if(n.type==="setUnvalidated"){var o;const{recoilValue:{key:r},unvalidatedValue:a}=n,s=mo(r);s==null||(o=s.invalidate)===null||o===void 0||o.call(s,t),t.atomValues.delete(r),t.nonvalidatedAtoms.set(r,a),t.dirtyAtoms.add(r)}else cn(`Unknown action ${n.type}`)}function Qt(e,t,n){n.state==="hasValue"&&n.contents instanceof pn?e.atomValues.delete(t):e.atomValues.set(t,n),e.dirtyAtoms.add(t),e.nonvalidatedAtoms.delete(t)}function Ro(e,t){e.replaceState(n=>{const o=yo(n);for(const r of t)fs(e,o,r);return go(e,o),cs(),o})}function Lt(e,t){if(tt.length){const n=tt[tt.length-1];let o=n.get(e);o||n.set(e,o=[]),o.push(t)}else Ro(e,[t])}const tt=[];function hs(){const e=new Map;return tt.push(e),()=>{for(const[t,n]of e)Ro(t,n);tt.pop()}}function yo(e){return{...e,atomValues:e.atomValues.clone(),nonvalidatedAtoms:e.nonvalidatedAtoms.clone(),dirtyAtoms:new Set(e.dirtyAtoms)}}function go(e,t){const n=Qa(e,t,t.dirtyAtoms);for(const a of n){var o,r;(o=mo(a))===null||o===void 0||(r=o.invalidate)===null||r===void 0||r.call(o,t)}}function bo(e,t,n){Lt(e,{type:"set",recoilValue:t,valueOrUpdater:n})}function vs(e,t,n){if(n instanceof pn)return bo(e,t,n);Lt(e,{type:"setLoadable",recoilValue:t,loadable:n})}function ps(e,t){Lt(e,{type:"markModified",recoilValue:t})}function _s(e,t,n){Lt(e,{type:"setUnvalidated",recoilValue:t,unvalidatedValue:n})}function Ss(e,{key:t},n,o=null){const r=ts(),a=e.getState();a.nodeToComponentSubscriptions.has(t)||a.nodeToComponentSubscriptions.set(t,new Map),q(a.nodeToComponentSubscriptions.get(t)).set(r,[o??"<not captured>",n]);const s=os();if(s.early&&(s.mode==="LEGACY"||s.mode==="MUTABLE_SOURCE")){const l=e.getState().nextTree;l&&l.dirtyAtoms.has(t)&&n(l)}return{release:()=>{const l=e.getState(),u=l.nodeToComponentSubscriptions.get(t);u===void 0||!u.has(r)||(u.delete(r),u.size===0&&l.nodeToComponentSubscriptions.delete(t))}}}function ms(e,t){var n;const{currentTree:o}=e.getState(),r=ns(t.key);(n=r.clearCache)===null||n===void 0||n.call(r,e,o)}var _e={RecoilValueReadOnly:ss,AbstractRecoilValue:rs,RecoilState:as,getRecoilValueAsLoadable:ls,setRecoilValue:bo,setRecoilValueLoadable:vs,markRecoilValueModified:ps,setUnvalidatedRecoilValue:_s,subscribeToRecoilValue:Ss,isRecoilValue:is,applyAtomValueWrites:us,batchStart:hs,writeLoadableToTreeState:Qt,invalidateDownstreams:go,copyTreeState:yo,refreshRecoilValue:ms};function Rs(e,t,n){const o=e.entries();let r=o.next();for(;!r.done;){const a=r.value;if(t.call(n,a[1],a[0],e))return!0;r=o.next()}return!1}var ys=Rs;const{cleanUpNode:gs}=Te,{deleteNodeConfigIfPossible:bs,getNode:To}=ce,{RetentionZone:wo}=Nt,Ts=12e4,Eo=new Set;function Ao(e,t){const n=e.getState(),o=n.currentTree;if(n.nextTree)return;const r=new Set;for(const s of t)if(s instanceof wo)for(const l of Ns(n,s))r.add(l);else r.add(s);const a=ws(e,r);for(const s of a)As(e,o,s)}function ws(e,t){const n=e.getState(),o=n.currentTree,r=e.getGraph(o.version),a=new Set,s=new Set;return l(t),a;function l(u){const f=new Set,v=Es(e,o,u,a,s);for(const y of v){var _;if(To(y).retainedBy==="recoilRoot"){s.add(y);continue}if(((_=n.retention.referenceCounts.get(y))!==null&&_!==void 0?_:0)>0){s.add(y);continue}if(No(y).some(Y=>n.retention.referenceCounts.get(Y))){s.add(y);continue}const E=r.nodeToNodeSubscriptions.get(y);if(E&&ys(E,Y=>s.has(Y))){s.add(y);continue}a.add(y),f.add(y)}const V=new Set;for(const y of f)for(const E of(C=r.nodeDeps.get(y))!==null&&C!==void 0?C:Eo){var C;a.has(E)||V.add(E)}V.size&&l(V)}}function Es(e,t,n,o,r){const a=e.getGraph(t.version),s=[],l=new Set;for(;n.size>0;)u(q(n.values().next().value));return s;function u(f){if(o.has(f)||r.has(f)){n.delete(f);return}if(l.has(f))return;const v=a.nodeToNodeSubscriptions.get(f);if(v)for(const _ of v)u(_);l.add(f),n.delete(f),s.push(f)}}function As(e,t,n){if(!W("recoil_memory_managament_2020"))return;gs(e,n);const o=e.getState();o.knownAtoms.delete(n),o.knownSelectors.delete(n),o.nodeTransactionSubscriptions.delete(n),o.retention.referenceCounts.delete(n);const r=No(n);for(const u of r){var a;(a=o.retention.nodesRetainedByZone.get(u))===null||a===void 0||a.delete(n)}t.atomValues.delete(n),t.dirtyAtoms.delete(n),t.nonvalidatedAtoms.delete(n);const s=o.graphsByVersion.get(t.version);if(s){const u=s.nodeDeps.get(n);if(u!==void 0){s.nodeDeps.delete(n);for(const f of u){var l;(l=s.nodeToNodeSubscriptions.get(f))===null||l===void 0||l.delete(n)}}s.nodeToNodeSubscriptions.delete(n)}bs(n)}function Ns(e,t){var n;return(n=e.retention.nodesRetainedByZone.get(t))!==null&&n!==void 0?n:Eo}function No(e){const t=To(e).retainedBy;return t===void 0||t==="components"||t==="recoilRoot"?[]:t instanceof wo?[t]:t}function Ls(e,t){const n=e.getState();n.nextTree?n.retention.retainablesToCheckForRelease.add(t):Ao(e,new Set([t]))}function Cs(e,t,n){var o;if(!W("recoil_memory_managament_2020"))return;const r=e.getState().retention.referenceCounts,a=((o=r.get(t))!==null&&o!==void 0?o:0)+n;a===0?Lo(e,t):r.set(t,a)}function Lo(e,t){if(!W("recoil_memory_managament_2020"))return;e.getState().retention.referenceCounts.delete(t),Ls(e,t)}function Vs(e){if(!W("recoil_memory_managament_2020"))return;const t=e.getState();Ao(e,t.retention.retainablesToCheckForRelease),t.retention.retainablesToCheckForRelease.clear()}function $s(e){return e===void 0?"recoilRoot":e}var $e={SUSPENSE_TIMEOUT_MS:Ts,updateRetainCount:Cs,updateRetainCountToZero:Lo,releaseScheduledRetainablesNow:Vs,retainedByOptionWithDefault:$s};const{unstable_batchedUpdates:Ms}=Er;var Is={unstable_batchedUpdates:Ms};const{unstable_batchedUpdates:Us}=Is;var ks={unstable_batchedUpdates:Us};const{batchStart:Ds}=_e,{unstable_batchedUpdates:Bs}=ks;let _n=Bs||(e=>e());const Ps=e=>{_n=e},Os=()=>_n,xs=e=>{_n(()=>{let t=()=>{};try{t=Ds(),e()}finally{t()}})};var Ct={getBatcher:Os,setBatcher:Ps,batchUpdates:xs};function*Fs(e){for(const t of e)for(const n of t)yield n}var Co=Fs;const Vo=typeof Window>"u"||typeof window>"u",zs=e=>!Vo&&(e===window||e instanceof Window),Ws=typeof navigator<"u"&&navigator.product==="ReactNative";var Vt={isSSR:Vo,isReactNative:Ws,isWindow:zs};function Gs(e,t){let n;return(...o)=>{n||(n={});const r=t(...o);return Object.hasOwnProperty.call(n,r)||(n[r]=e(...o)),n[r]}}function Ks(e,t){let n,o;return(...r)=>{const a=t(...r);return n===a||(n=a,o=e(...r)),o}}function Hs(e,t){let n,o;return[(...s)=>{const l=t(...s);return n===l||(n=l,o=e(...s)),o},()=>{n=null}]}var js={memoizeWithArgsHash:Gs,memoizeOneWithArgsHash:Ks,memoizeOneWithArgsHashAndInvalidation:Hs};const{batchUpdates:en}=Ct,{initializeNode:qs,peekNodeInfo:Zs}=Te,{graph:Ys}=st,{getNextStoreID:Xs}=At,{DEFAULT_VALUE:Js,recoilValues:$n,recoilValuesForKeys:Mn}=ce,{AbstractRecoilValue:Qs,getRecoilValueAsLoadable:ei,setRecoilValue:In,setUnvalidatedRecoilValue:ti}=_e,{updateRetainCount:_t}=$e,{setInvalidateMemoizedSnapshot:ni}=_o,{getNextTreeStateVersion:oi,makeEmptyStoreState:ri}=co,{isSSR:ai}=Vt,{memoizeOneWithArgsHashAndInvalidation:si}=js;class $t{constructor(t,n){M(this,"_store",void 0),M(this,"_refCount",1),M(this,"getLoadable",o=>(this.checkRefCount_INTERNAL(),ei(this._store,o))),M(this,"getPromise",o=>(this.checkRefCount_INTERNAL(),this.getLoadable(o).toPromise())),M(this,"getNodes_UNSTABLE",o=>{if(this.checkRefCount_INTERNAL(),(o==null?void 0:o.isModified)===!0){if((o==null?void 0:o.isInitialized)===!1)return[];const s=this._store.getState().currentTree;return Mn(s.dirtyAtoms)}const r=this._store.getState().knownAtoms,a=this._store.getState().knownSelectors;return(o==null?void 0:o.isInitialized)==null?$n.values():o.isInitialized===!0?Mn(Co([r,a])):hn($n.values(),({key:s})=>!r.has(s)&&!a.has(s))}),M(this,"getInfo_UNSTABLE",({key:o})=>(this.checkRefCount_INTERNAL(),Zs(this._store,this._store.getState().currentTree,o))),M(this,"map",o=>{this.checkRefCount_INTERNAL();const r=new tn(this,en);return o(r),r}),M(this,"asyncMap",async o=>{this.checkRefCount_INTERNAL();const r=new tn(this,en);return r.retain(),await o(r),r.autoRelease_INTERNAL(),r}),this._store={storeID:Xs(),parentStoreID:n,getState:()=>t,replaceState:o=>{t.currentTree=o(t.currentTree)},getGraph:o=>{const r=t.graphsByVersion;if(r.has(o))return q(r.get(o));const a=Ys();return r.set(o,a),a},subscribeToTransactions:()=>({release:()=>{}}),addTransactionMetadata:()=>{throw I("Cannot subscribe to Snapshots")}};for(const o of this._store.getState().knownAtoms)qs(this._store,o,"get"),_t(this._store,o,1);this.autoRelease_INTERNAL()}retain(){this._refCount<=0,this._refCount++;let t=!1;return()=>{t||(t=!0,this._release())}}autoRelease_INTERNAL(){ai||window.setTimeout(()=>this._release(),10)}_release(){if(this._refCount--,this._refCount===0){if(this._store.getState().nodeCleanupFunctions.forEach(t=>t()),this._store.getState().nodeCleanupFunctions.clear(),!W("recoil_memory_managament_2020"))return}else this._refCount<0}isRetained(){return this._refCount>0}checkRefCount_INTERNAL(){W("recoil_memory_managament_2020")&&this._refCount<=0}getStore_INTERNAL(){return this.checkRefCount_INTERNAL(),this._store}getID(){return this.checkRefCount_INTERNAL(),this._store.getState().currentTree.stateID}getStoreID(){return this.checkRefCount_INTERNAL(),this._store.storeID}}function $o(e,t,n=!1){const o=e.getState(),r=n?oi():t.version;return{currentTree:{version:n?r:t.version,stateID:n?r:t.stateID,transactionMetadata:{...t.transactionMetadata},dirtyAtoms:new Set(t.dirtyAtoms),atomValues:t.atomValues.clone(),nonvalidatedAtoms:t.nonvalidatedAtoms.clone()},commitDepth:0,nextTree:null,previousTree:null,knownAtoms:new Set(o.knownAtoms),knownSelectors:new Set(o.knownSelectors),transactionSubscriptions:new Map,nodeTransactionSubscriptions:new Map,nodeToComponentSubscriptions:new Map,queuedComponentCallbacks_DEPRECATED:[],suspendedComponentResolvers:new Set,graphsByVersion:new Map().set(r,e.getGraph(t.version)),retention:{referenceCounts:new Map,nodesRetainedByZone:new Map,retainablesToCheckForRelease:new Set},nodeCleanupFunctions:new Map(Et(o.nodeCleanupFunctions.entries(),([a])=>[a,()=>{}]))}}function ii(e){const t=new $t(ri());return e!=null?t.map(e):t}const[Un,Mo]=si((e,t)=>{var n;const o=e.getState(),r=t==="latest"?(n=o.nextTree)!==null&&n!==void 0?n:o.currentTree:q(o.previousTree);return new $t($o(e,r),e.storeID)},(e,t)=>{var n,o;return String(t)+String(e.storeID)+String((n=e.getState().nextTree)===null||n===void 0?void 0:n.version)+String(e.getState().currentTree.version)+String((o=e.getState().previousTree)===null||o===void 0?void 0:o.version)});ni(Mo);function ci(e,t="latest"){const n=Un(e,t);return n.isRetained()?n:(Mo(),Un(e,t))}class tn extends $t{constructor(t,n){super($o(t.getStore_INTERNAL(),t.getStore_INTERNAL().getState().currentTree,!0),t.getStoreID()),M(this,"_batch",void 0),M(this,"set",(o,r)=>{this.checkRefCount_INTERNAL();const a=this.getStore_INTERNAL();this._batch(()=>{_t(a,o.key,1),In(this.getStore_INTERNAL(),o,r)})}),M(this,"reset",o=>{this.checkRefCount_INTERNAL();const r=this.getStore_INTERNAL();this._batch(()=>{_t(r,o.key,1),In(this.getStore_INTERNAL(),o,Js)})}),M(this,"setUnvalidatedAtomValues_DEPRECATED",o=>{this.checkRefCount_INTERNAL();const r=this.getStore_INTERNAL();en(()=>{for(const[a,s]of o.entries())_t(r,a,1),ti(r,new Qs(a),s)})}),this._batch=n}}var Mt={Snapshot:$t,MutableSnapshot:tn,freshSnapshot:ii,cloneSnapshot:ci},li=Mt.Snapshot,ui=Mt.MutableSnapshot,di=Mt.freshSnapshot,fi=Mt.cloneSnapshot,It=Object.freeze({__proto__:null,Snapshot:li,MutableSnapshot:ui,freshSnapshot:di,cloneSnapshot:fi});function hi(...e){const t=new Set;for(const n of e)for(const o of n)t.add(o);return t}var vi=hi;const{useRef:pi}=Z;function _i(e){const t=pi(e);return t.current===e&&typeof e=="function"&&(t.current=e()),t}var kn=_i;const{getNextTreeStateVersion:Si,makeEmptyStoreState:Io}=co,{cleanUpNode:mi,getDownstreamNodes:Ri,initializeNode:yi,setNodeValue:gi,setUnvalidatedAtomValue_DEPRECATED:bi}=Te,{graph:Ti}=st,{cloneGraph:wi}=st,{getNextStoreID:Uo}=At,{createMutableSource:qt,reactMode:ko}=at,{applyAtomValueWrites:Ei}=_e,{releaseScheduledRetainablesNow:Do}=$e,{freshSnapshot:Ai}=It,{useCallback:Ni,useContext:Bo,useEffect:nn,useMemo:Li,useRef:Ci,useState:Vi}=Z;function qe(){throw I("This component must be used inside a <RecoilRoot> component.")}const Po=Object.freeze({storeID:Uo(),getState:qe,replaceState:qe,getGraph:qe,subscribeToTransactions:qe,addTransactionMetadata:qe});let on=!1;function Dn(e){if(on)throw I("An atom update was triggered within the execution of a state updater function. State updater functions provided to Recoil must be pure functions.");const t=e.getState();if(t.nextTree===null){W("recoil_memory_managament_2020")&&W("recoil_release_on_cascading_update_killswitch_2021")&&t.commitDepth>0&&Do(e);const n=t.currentTree.version,o=Si();t.nextTree={...t.currentTree,version:o,stateID:o,dirtyAtoms:new Set,transactionMetadata:{}},t.graphsByVersion.set(o,wi(q(t.graphsByVersion.get(n))))}}const Oo=Z.createContext({current:Po}),Ut=()=>Bo(Oo),xo=Z.createContext(null);function $i(){return Bo(xo)}function Sn(e,t,n){const o=Ri(e,n,n.dirtyAtoms);for(const r of o){const a=t.nodeToComponentSubscriptions.get(r);if(a)for(const[s,[l,u]]of a)u(n)}}function Fo(e){const t=e.getState(),n=t.currentTree,o=n.dirtyAtoms;if(o.size){for(const[r,a]of t.nodeTransactionSubscriptions)if(o.has(r))for(const[s,l]of a)l(e);for(const[r,a]of t.transactionSubscriptions)a(e);(!ko().early||t.suspendedComponentResolvers.size>0)&&(Sn(e,t,n),t.suspendedComponentResolvers.forEach(r=>r()),t.suspendedComponentResolvers.clear())}t.queuedComponentCallbacks_DEPRECATED.forEach(r=>r(n)),t.queuedComponentCallbacks_DEPRECATED.splice(0,t.queuedComponentCallbacks_DEPRECATED.length)}function Mi(e){const t=e.getState();t.commitDepth++;try{const{nextTree:n}=t;if(n==null)return;t.previousTree=t.currentTree,t.currentTree=n,t.nextTree=null,Fo(e),t.previousTree!=null?t.graphsByVersion.delete(t.previousTree.version):cn("Ended batch with no previous state, which is unexpected","recoil"),t.previousTree=null,W("recoil_memory_managament_2020")&&n==null&&Do(e)}finally{t.commitDepth--}}function Ii({setNotifyBatcherOfChange:e}){const t=Ut(),[,n]=Vi([]);return e(()=>n({})),nn(()=>(e(()=>n({})),()=>{e(()=>{})}),[e]),nn(()=>{da.enqueueExecution("Batcher",()=>{Mi(t.current)})}),null}function Ui(e,t){const n=Io();return t({set:(o,r)=>{const a=n.currentTree,s=gi(e,a,o.key,r),l=new Set(s.keys()),u=a.nonvalidatedAtoms.clone();for(const f of l)u.delete(f);n.currentTree={...a,dirtyAtoms:vi(a.dirtyAtoms,l),atomValues:Ei(a.atomValues,s),nonvalidatedAtoms:u}},setUnvalidatedAtomValues:o=>{o.forEach((r,a)=>{n.currentTree=bi(n.currentTree,a,r)})}}),n}function ki(e){const t=Ai(e),n=t.getStore_INTERNAL().getState();return t.retain(),n.nodeCleanupFunctions.forEach(o=>o()),n.nodeCleanupFunctions.clear(),n}let Bn=0;function Di({initializeState_DEPRECATED:e,initializeState:t,store_INTERNAL:n,children:o}){let r;const a=C=>{const y=r.current.graphsByVersion;if(y.has(C))return q(y.get(C));const E=Ti();return y.set(C,E),E},s=(C,y)=>{if(y==null){const{transactionSubscriptions:E}=_.current.getState(),Y=Bn++;return E.set(Y,C),{release:()=>{E.delete(Y)}}}else{const{nodeTransactionSubscriptions:E}=_.current.getState();E.has(y)||E.set(y,new Map);const Y=Bn++;return q(E.get(y)).set(Y,C),{release:()=>{const te=E.get(y);te&&(te.delete(Y),te.size===0&&E.delete(y))}}}},l=C=>{Dn(_.current);for(const y of Object.keys(C))q(_.current.getState().nextTree).transactionMetadata[y]=C[y]},u=C=>{Dn(_.current);const y=q(r.current.nextTree);let E;try{on=!0,E=C(y)}finally{on=!1}E!==y&&(r.current.nextTree=E,ko().early&&Sn(_.current,r.current,E),q(f.current)())},f=Ci(null),v=Ni(C=>{f.current=C},[f]),_=kn(()=>n??{storeID:Uo(),getState:()=>r.current,replaceState:u,getGraph:a,subscribeToTransactions:s,addTransactionMetadata:l});n!=null&&(_.current=n),r=kn(()=>e!=null?Ui(_.current,e):t!=null?ki(t):Io());const V=Li(()=>qt==null?void 0:qt(r,()=>r.current.currentTree.version),[r]);return nn(()=>{const C=_.current;for(const y of new Set(C.getState().knownAtoms))yi(C,y,"get");return()=>{for(const y of C.getState().knownAtoms)mi(C,y)}},[_]),Z.createElement(Oo.Provider,{value:_},Z.createElement(xo.Provider,{value:V},Z.createElement(Ii,{setNotifyBatcherOfChange:v}),o))}function Bi(e){const{override:t,...n}=e,o=Ut();return t===!1&&o.current!==Po?e.children:Z.createElement(Di,n)}function Pi(){return Ut().current.storeID}var ye={RecoilRoot:Bi,useStoreRef:Ut,useRecoilMutableSource:$i,useRecoilStoreID:Pi,notifyComponents_FOR_TESTING:Sn,sendEndOfBatchNotifications_FOR_TESTING:Fo};function Oi(e,t){if(e===t)return!0;if(e.length!==t.length)return!1;for(let n=0,o=e.length;n<o;n++)if(e[n]!==t[n])return!1;return!0}var xi=Oi;const{useEffect:Fi,useRef:zi}=Z;function Wi(e){const t=zi();return Fi(()=>{t.current=e}),t.current}var zo=Wi;const{useStoreRef:Gi}=ye,{SUSPENSE_TIMEOUT_MS:Ki}=$e,{updateRetainCount:Ze}=$e,{RetentionZone:Hi}=Nt,{useEffect:ji,useRef:qi}=Z,{isSSR:Pn}=Vt;function Zi(e){if(W("recoil_memory_managament_2020"))return Yi(e)}function Yi(e){const n=(Array.isArray(e)?e:[e]).map(s=>s instanceof Hi?s:s.key),o=Gi();ji(()=>{if(!W("recoil_memory_managament_2020"))return;const s=o.current;if(r.current&&!Pn)window.clearTimeout(r.current),r.current=null;else for(const l of n)Ze(s,l,1);return()=>{for(const l of n)Ze(s,l,-1)}},[o,...n]);const r=qi(),a=zo(n);if(!Pn&&(a===void 0||!xi(a,n))){const s=o.current;for(const l of n)Ze(s,l,1);if(a)for(const l of a)Ze(s,l,-1);r.current&&window.clearTimeout(r.current),r.current=window.setTimeout(()=>{r.current=null;for(const l of n)Ze(s,l,-1)},Ki)}}var mn=Zi;function Xi(){return"<component name not available>"}var ct=Xi;const{batchUpdates:Ji}=Ct,{DEFAULT_VALUE:Wo}=ce,{currentRendererSupportsUseSyncExternalStore:Qi,reactMode:Ke,useMutableSource:ec,useSyncExternalStore:tc}=at,{useRecoilMutableSource:nc,useStoreRef:Se}=ye,{AbstractRecoilValue:rn,getRecoilValueAsLoadable:lt,setRecoilValue:Rt,setUnvalidatedRecoilValue:oc,subscribeToRecoilValue:Fe}=_e,{useCallback:ie,useEffect:ze,useMemo:Go,useRef:nt,useState:Rn}=Z,{setByAddingToSet:rc}=uo,{isSSR:ac}=Vt;function yn(e,t,n){if(e.state==="hasValue")return e.contents;throw e.state==="loading"?new Promise(r=>{const a=n.current.getState().suspendedComponentResolvers;a.add(r),ac&&G(e.contents)&&e.contents.finally(()=>{a.delete(r)})}):e.state==="hasError"?e.contents:I(`Invalid value of loadable atom "${t.key}"`)}function sc(){const e=ct(),t=Se(),[,n]=Rn([]),o=nt(new Set);o.current=new Set;const r=nt(new Set),a=nt(new Map),s=ie(u=>{const f=a.current.get(u);f&&(f.release(),a.current.delete(u))},[a]),l=ie((u,f)=>{a.current.has(f)&&n([])},[]);return ze(()=>{const u=t.current;et(o.current,r.current).forEach(f=>{if(a.current.has(f))return;const v=Fe(u,new rn(f),V=>l(V,f),e);a.current.set(f,v),u.getState().nextTree?u.getState().queuedComponentCallbacks_DEPRECATED.push(()=>{l(u.getState(),f)}):l(u.getState(),f)}),et(r.current,o.current).forEach(f=>{s(f)}),r.current=o.current}),ze(()=>{const u=a.current;return et(o.current,new Set(u.keys())).forEach(f=>{const v=Fe(t.current,new rn(f),_=>l(_,f),e);u.set(f,v)}),()=>u.forEach((f,v)=>s(v))},[e,t,s,l]),Go(()=>{function u(y){return E=>{Rt(t.current,y,E)}}function f(y){return()=>Rt(t.current,y,Wo)}function v(y){var E;o.current.has(y.key)||(o.current=rc(o.current,y.key));const Y=t.current.getState();return lt(t.current,y,Ke().early&&(E=Y.nextTree)!==null&&E!==void 0?E:Y.currentTree)}function _(y){const E=v(y);return yn(E,y,t)}function V(y){return[_(y),u(y)]}function C(y){return[v(y),u(y)]}return{getRecoilValue:_,getRecoilValueLoadable:v,getRecoilState:V,getRecoilStateLoadable:C,getSetRecoilState:u,getResetRecoilState:f}},[o,t])}const ic={current:0};function cc(e){const t=Se(),n=ct(),o=ie(()=>{var l;const u=t.current,f=u.getState(),v=Ke().early&&(l=f.nextTree)!==null&&l!==void 0?l:f.currentTree;return{loadable:lt(u,e,v),key:e.key}},[t,e]),r=ie(l=>{let u;return()=>{var f,v;const _=l();return(f=u)!==null&&f!==void 0&&f.loadable.is(_.loadable)&&((v=u)===null||v===void 0?void 0:v.key)===_.key?u:(u=_,_)}},[]),a=Go(()=>r(o),[o,r]),s=ie(l=>{const u=t.current;return Fe(u,e,l,n).release},[t,e,n]);return tc(s,a,a).loadable}function lc(e){const t=Se(),n=ie(()=>{var f;const v=t.current,_=v.getState(),V=Ke().early&&(f=_.nextTree)!==null&&f!==void 0?f:_.currentTree;return lt(v,e,V)},[t,e]),o=ie(()=>n(),[n]),r=ct(),a=ie((f,v)=>{const _=t.current;return Fe(_,e,()=>{if(!W("recoil_suppress_rerender_in_callback"))return v();const C=n();u.current.is(C)||v(),u.current=C},r).release},[t,e,r,n]),s=nc();if(s==null)throw I("Recoil hooks must be used in components contained within a <RecoilRoot> component.");const l=ec(s,o,a),u=nt(l);return ze(()=>{u.current=l}),l}function an(e){const t=Se(),n=ct(),o=ie(()=>{var u;const f=t.current,v=f.getState(),_=Ke().early&&(u=v.nextTree)!==null&&u!==void 0?u:v.currentTree;return lt(f,e,_)},[t,e]),r=ie(()=>({loadable:o(),key:e.key}),[o,e.key]),a=ie(u=>{const f=r();return u.loadable.is(f.loadable)&&u.key===f.key?u:f},[r]);ze(()=>{const u=Fe(t.current,e,f=>{l(a)},n);return l(a),u.release},[n,e,t,a]);const[s,l]=Rn(r);return s.key!==e.key?r().loadable:s.loadable}function uc(e){const t=Se(),[,n]=Rn([]),o=ct(),r=ie(()=>{var l;const u=t.current,f=u.getState(),v=Ke().early&&(l=f.nextTree)!==null&&l!==void 0?l:f.currentTree;return lt(u,e,v)},[t,e]),a=r(),s=nt(a);return ze(()=>{s.current=a}),ze(()=>{const l=t.current,u=l.getState(),f=Fe(l,e,_=>{var V;if(!W("recoil_suppress_rerender_in_callback"))return n([]);const C=r();(V=s.current)!==null&&V!==void 0&&V.is(C)||n(C),s.current=C},o);if(u.nextTree)l.getState().queuedComponentCallbacks_DEPRECATED.push(()=>{s.current=null,n([])});else{var v;if(!W("recoil_suppress_rerender_in_callback"))return n([]);const _=r();(v=s.current)!==null&&v!==void 0&&v.is(_)||n(_),s.current=_}return f.release},[o,r,e,t]),a}function gn(e){return W("recoil_memory_managament_2020")&&mn(e),{TRANSITION_SUPPORT:an,SYNC_EXTERNAL_STORE:Qi()?cc:an,MUTABLE_SOURCE:lc,LEGACY:uc}[Ke().mode](e)}function Ko(e){const t=Se(),n=gn(e);return yn(n,e,t)}function kt(e){const t=Se();return ie(n=>{Rt(t.current,e,n)},[t,e])}function dc(e){const t=Se();return ie(()=>{Rt(t.current,e,Wo)},[t,e])}function fc(e){return[Ko(e),kt(e)]}function hc(e){return[gn(e),kt(e)]}function vc(){const e=Se();return(t,n={})=>{Ji(()=>{e.current.addTransactionMetadata(n),t.forEach((o,r)=>oc(e.current,new rn(r),o))})}}function Ho(e){return W("recoil_memory_managament_2020")&&mn(e),an(e)}function jo(e){const t=Se(),n=Ho(e);return yn(n,e,t)}function pc(e){return[jo(e),kt(e)]}var _c={recoilComponentGetRecoilValueCount_FOR_TESTING:ic,useRecoilInterface:sc,useRecoilState:fc,useRecoilStateLoadable:hc,useRecoilValue:Ko,useRecoilValueLoadable:gn,useResetRecoilState:dc,useSetRecoilState:kt,useSetUnvalidatedAtomValues:vc,useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE:Ho,useRecoilValue_TRANSITION_SUPPORT_UNSTABLE:jo,useRecoilState_TRANSITION_SUPPORT_UNSTABLE:pc};function Sc(e,t){const n=new Map;for(const[o,r]of e)t(r,o)&&n.set(o,r);return n}var mc=Sc;function Rc(e,t){const n=new Set;for(const o of e)t(o)&&n.add(o);return n}var yc=Rc;function gc(...e){const t=new Map;for(let n=0;n<e.length;n++){const o=e[n].keys();let r;for(;!(r=o.next()).done;)t.set(r.value,e[n].get(r.value))}return t}var bc=gc;const{batchUpdates:Tc}=Ct,{DEFAULT_VALUE:wc,getNode:qo,nodes:Ec}=ce,{useStoreRef:bn}=ye,{AbstractRecoilValue:Ac,setRecoilValueLoadable:Nc}=_e,{SUSPENSE_TIMEOUT_MS:Lc}=$e,{cloneSnapshot:yt}=It,{useCallback:Dt,useEffect:Zo,useRef:On,useState:Cc}=Z,{isSSR:xn}=Vt;function Bt(e){const t=bn();Zo(()=>t.current.subscribeToTransactions(e).release,[e,t])}function Fn(e){const t=e.atomValues.toMap(),n=mt(mc(t,(o,r)=>{const s=qo(r).persistence_UNSTABLE;return s!=null&&s.type!=="none"&&o.state==="hasValue"}),o=>o.contents);return bc(e.nonvalidatedAtoms.toMap(),n)}function Vc(e){Bt(Dt(t=>{let n=t.getState().previousTree;const o=t.getState().currentTree;n||(n=t.getState().currentTree);const r=Fn(o),a=Fn(n),s=mt(Ec,u=>{var f,v,_,V;return{persistence_UNSTABLE:{type:(f=(v=u.persistence_UNSTABLE)===null||v===void 0?void 0:v.type)!==null&&f!==void 0?f:"none",backButton:(_=(V=u.persistence_UNSTABLE)===null||V===void 0?void 0:V.backButton)!==null&&_!==void 0?_:!1}}}),l=yc(o.dirtyAtoms,u=>r.has(u)||a.has(u));e({atomValues:r,previousAtomValues:a,atomInfo:s,modifiedAtoms:l,transactionMetadata:{...o.transactionMetadata}})},[e]))}function $c(e){Bt(Dt(t=>{const n=yt(t,"latest"),o=yt(t,"previous");e({snapshot:n,previousSnapshot:o})},[e]))}function Mc(){const e=bn(),[t,n]=Cc(()=>yt(e.current)),o=zo(t),r=On(),a=On();if(Bt(Dt(l=>n(yt(l)),[])),Zo(()=>{const l=t.retain();if(r.current&&!xn){var u;window.clearTimeout(r.current),r.current=null,(u=a.current)===null||u===void 0||u.call(a),a.current=null}return()=>{window.setTimeout(l,10)}},[t]),o!==t&&!xn){if(r.current){var s;window.clearTimeout(r.current),r.current=null,(s=a.current)===null||s===void 0||s.call(a),a.current=null}a.current=t.retain(),r.current=window.setTimeout(()=>{var l;r.current=null,(l=a.current)===null||l===void 0||l.call(a),a.current=null},Lc)}return t}function Yo(e,t){var n;const o=e.getState(),r=(n=o.nextTree)!==null&&n!==void 0?n:o.currentTree,a=t.getStore_INTERNAL().getState().currentTree;Tc(()=>{const s=new Set;for(const f of[r.atomValues.keys(),a.atomValues.keys()])for(const v of f){var l,u;((l=r.atomValues.get(v))===null||l===void 0?void 0:l.contents)!==((u=a.atomValues.get(v))===null||u===void 0?void 0:u.contents)&&qo(v).shouldRestoreFromSnapshots&&s.add(v)}s.forEach(f=>{Nc(e,new Ac(f),a.atomValues.has(f)?q(a.atomValues.get(f)):wc)}),e.replaceState(f=>({...f,stateID:t.getID()}))})}function Ic(){const e=bn();return Dt(t=>Yo(e.current,t),[e])}var Xo={useRecoilSnapshot:Mc,gotoSnapshot:Yo,useGotoRecoilSnapshot:Ic,useRecoilTransactionObserver:$c,useTransactionObservation_DEPRECATED:Vc,useTransactionSubscription_DEPRECATED:Bt};const{peekNodeInfo:Uc}=Te,{useStoreRef:kc}=ye;function Dc(){const e=kc();return({key:t})=>Uc(e.current,e.current.getState().currentTree,t)}var Bc=Dc;const{reactMode:Pc}=at,{RecoilRoot:Oc,useStoreRef:xc}=ye,{useMemo:Fc}=Z;function zc(){Pc().mode==="MUTABLE_SOURCE"&&console.warn("Warning: There are known issues using useRecoilBridgeAcrossReactRoots() in recoil_mutable_source rendering mode.  Please consider upgrading to recoil_sync_external_store mode.");const e=xc().current;return Fc(()=>{function t({children:n}){return Z.createElement(Oc,{store_INTERNAL:e},n)}return t},[e])}var Wc=zc;const{loadableWithValue:Gc}=rt,{initializeNode:Kc}=Te,{DEFAULT_VALUE:Hc,getNode:jc}=ce,{copyTreeState:qc,getRecoilValueAsLoadable:Zc,invalidateDownstreams:Yc,writeLoadableToTreeState:Xc}=_e;function zn(e){return jc(e.key).nodeType==="atom"}class Jc{constructor(t,n){M(this,"_store",void 0),M(this,"_treeState",void 0),M(this,"_changes",void 0),M(this,"get",o=>{if(this._changes.has(o.key))return this._changes.get(o.key);if(!zn(o))throw I("Reading selectors within atomicUpdate is not supported");const r=Zc(this._store,o,this._treeState);if(r.state==="hasValue")return r.contents;throw r.state==="hasError"?r.contents:I(`Expected Recoil atom ${o.key} to have a value, but it is in a loading state.`)}),M(this,"set",(o,r)=>{if(!zn(o))throw I("Setting selectors within atomicUpdate is not supported");if(typeof r=="function"){const a=this.get(o);this._changes.set(o.key,r(a))}else Kc(this._store,o.key,"set"),this._changes.set(o.key,r)}),M(this,"reset",o=>{this.set(o,Hc)}),this._store=t,this._treeState=n,this._changes=new Map}newTreeState_INTERNAL(){if(this._changes.size===0)return this._treeState;const t=qc(this._treeState);for(const[n,o]of this._changes)Xc(t,n,Gc(o));return Yc(this._store,t),t}}function Qc(e){return t=>{e.replaceState(n=>{const o=new Jc(e,n);return t(o),o.newTreeState_INTERNAL()})}}var el={atomicUpdater:Qc},tl=el.atomicUpdater,Jo=Object.freeze({__proto__:null,atomicUpdater:tl});function nl(e,t){if(!e)throw new Error(t)}var ol=nl,Qe=ol;const{atomicUpdater:rl}=Jo,{batchUpdates:al}=Ct,{DEFAULT_VALUE:sl}=ce,{useStoreRef:il}=ye,{refreshRecoilValue:cl,setRecoilValue:Wn}=_e,{cloneSnapshot:ll}=It,{gotoSnapshot:ul}=Xo,{useCallback:dl}=Z;class Qo{}const fl=new Qo;function er(e,t,n,o){let r=fl,a;if(al(()=>{const l="useRecoilCallback() expects a function that returns a function: it accepts a function of the type (RecoilInterface) => (Args) => ReturnType and returns a callback function (Args) => ReturnType, where RecoilInterface is an object {snapshot, set, ...} and Args and ReturnType are the argument and return types of the callback you want to create.  Please see the docs at recoiljs.org for details.";if(typeof t!="function")throw I(l);const u=fo({...o??{},set:(v,_)=>Wn(e,v,_),reset:v=>Wn(e,v,sl),refresh:v=>cl(e,v),gotoSnapshot:v=>ul(e,v),transact_UNSTABLE:v=>rl(e)(v)},{snapshot:()=>{const v=ll(e);return a=v.retain(),v}}),f=t(u);if(typeof f!="function")throw I(l);r=f(...n)}),r instanceof Qo&&Qe(!1),G(r))r=r.finally(()=>{var l;(l=a)===null||l===void 0||l()});else{var s;(s=a)===null||s===void 0||s()}return r}function hl(e,t){const n=il();return dl((...o)=>er(n.current,e,o),t!=null?[...t,n]:void 0)}var tr={recoilCallback:er,useRecoilCallback:hl};const{useStoreRef:vl}=ye,{refreshRecoilValue:pl}=_e,{useCallback:_l}=Z;function Sl(e){const t=vl();return _l(()=>{const n=t.current;pl(n,e)},[e,t])}var ml=Sl;const{atomicUpdater:Rl}=Jo,{useStoreRef:yl}=ye,{useMemo:gl}=Z;function bl(e,t){const n=yl();return gl(()=>(...o)=>{Rl(n.current)(a=>{e(a)(...o)})},t!=null?[...t,n]:void 0)}var Tl=bl;class wl{constructor(t){M(this,"value",void 0),this.value=t}}var El={WrappedValue:wl},Al=El.WrappedValue,nr=Object.freeze({__proto__:null,WrappedValue:Al});const{isFastRefreshEnabled:Nl}=at;class Gn extends Error{}class Ll{constructor(t){var n,o,r;M(this,"_name",void 0),M(this,"_numLeafs",void 0),M(this,"_root",void 0),M(this,"_onHit",void 0),M(this,"_onSet",void 0),M(this,"_mapNodeValue",void 0),this._name=t==null?void 0:t.name,this._numLeafs=0,this._root=null,this._onHit=(n=t==null?void 0:t.onHit)!==null&&n!==void 0?n:()=>{},this._onSet=(o=t==null?void 0:t.onSet)!==null&&o!==void 0?o:()=>{},this._mapNodeValue=(r=t==null?void 0:t.mapNodeValue)!==null&&r!==void 0?r:a=>a}size(){return this._numLeafs}root(){return this._root}get(t,n){var o;return(o=this.getLeafNode(t,n))===null||o===void 0?void 0:o.value}getLeafNode(t,n){if(this._root==null)return;let o=this._root;for(;o;){if(n==null||n.onNodeVisit(o),o.type==="leaf")return this._onHit(o),o;const r=this._mapNodeValue(t(o.nodeKey));o=o.branches.get(r)}}set(t,n,o){const r=()=>{var a,s,l,u;let f,v;for(const[Y,te]of t){var _,V,C;const w=this._root;if((w==null?void 0:w.type)==="leaf")throw this.invalidCacheError();const B=f;if(f=B?B.branches.get(v):w,f=(_=f)!==null&&_!==void 0?_:{type:"branch",nodeKey:Y,parent:B,branches:new Map,branchKey:v},f.type!=="branch"||f.nodeKey!==Y)throw this.invalidCacheError();B==null||B.branches.set(v,f),o==null||(V=o.onNodeVisit)===null||V===void 0||V.call(o,f),v=this._mapNodeValue(te),this._root=(C=this._root)!==null&&C!==void 0?C:f}const y=f?(a=f)===null||a===void 0?void 0:a.branches.get(v):this._root;if(y!=null&&(y.type!=="leaf"||y.branchKey!==v))throw this.invalidCacheError();const E={type:"leaf",value:n,parent:f,branchKey:v};(s=f)===null||s===void 0||s.branches.set(v,E),this._root=(l=this._root)!==null&&l!==void 0?l:E,this._numLeafs++,this._onSet(E),o==null||(u=o.onNodeVisit)===null||u===void 0||u.call(o,E)};try{r()}catch(a){if(a instanceof Gn)this.clear(),r();else throw a}}delete(t){const n=this.root();if(!n)return!1;if(t===n)return this._root=null,this._numLeafs=0,!0;let o=t.parent,r=t.branchKey;for(;o;){var a;if(o.branches.delete(r),o===n)return o.branches.size===0?(this._root=null,this._numLeafs=0):this._numLeafs--,!0;if(o.branches.size>0)break;r=(a=o)===null||a===void 0?void 0:a.branchKey,o=o.parent}for(;o!==n;o=o.parent)if(o==null)return!1;return this._numLeafs--,!0}clear(){this._numLeafs=0,this._root=null}invalidCacheError(){const t=Nl()?"Possible Fast Refresh module reload detected.  This may also be caused by an selector returning inconsistent values. Resetting cache.":"Invalid cache values.  This happens when selectors do not return consistent values for the same input dependency values.  That may also be caused when using Fast Refresh to change a selector implementation.  Resetting cache.";throw cn(t+(this._name!=null?` - ${this._name}`:"")),new Gn}}var Cl={TreeCache:Ll},Vl=Cl.TreeCache,or=Object.freeze({__proto__:null,TreeCache:Vl});class $l{constructor(t){var n;M(this,"_maxSize",void 0),M(this,"_size",void 0),M(this,"_head",void 0),M(this,"_tail",void 0),M(this,"_map",void 0),M(this,"_keyMapper",void 0),this._maxSize=t.maxSize,this._size=0,this._head=null,this._tail=null,this._map=new Map,this._keyMapper=(n=t.mapKey)!==null&&n!==void 0?n:o=>o}head(){return this._head}tail(){return this._tail}size(){return this._size}maxSize(){return this._maxSize}has(t){return this._map.has(this._keyMapper(t))}get(t){const n=this._keyMapper(t),o=this._map.get(n);if(o)return this.set(t,o.value),o.value}set(t,n){const o=this._keyMapper(t);this._map.get(o)&&this.delete(t);const a=this.head(),s={key:t,right:a,left:null,value:n};a?a.left=s:this._tail=s,this._map.set(o,s),this._head=s,this._size++,this._maybeDeleteLRU()}_maybeDeleteLRU(){this.size()>this.maxSize()&&this.deleteLru()}deleteLru(){const t=this.tail();t&&this.delete(t.key)}delete(t){const n=this._keyMapper(t);if(!this._size||!this._map.has(n))return;const o=q(this._map.get(n)),r=o.right,a=o.left;r&&(r.left=o.left),a&&(a.right=o.right),o===this.head()&&(this._head=r),o===this.tail()&&(this._tail=a),this._map.delete(n),this._size--}clear(){this._size=0,this._head=null,this._tail=null,this._map=new Map}}var Ml={LRUCache:$l},Il=Ml.LRUCache,rr=Object.freeze({__proto__:null,LRUCache:Il});const{LRUCache:Ul}=rr,{TreeCache:kl}=or;function Dl({name:e,maxSize:t,mapNodeValue:n=o=>o}){const o=new Ul({maxSize:t}),r=new kl({name:e,mapNodeValue:n,onHit:a=>{o.set(a,!0)},onSet:a=>{const s=o.tail();o.set(a,!0),s&&r.size()>t&&r.delete(s.key)}});return r}var Kn=Dl;function pe(e,t,n){if(typeof e=="string"&&!e.includes('"')&&!e.includes("\\"))return`"${e}"`;switch(typeof e){case"undefined":return"";case"boolean":return e?"true":"false";case"number":case"symbol":return String(e);case"string":return JSON.stringify(e);case"function":if((t==null?void 0:t.allowFunctions)!==!0)throw I("Attempt to serialize function in a Recoil cache key");return`__FUNCTION(${e.name})__`}if(e===null)return"null";if(typeof e!="object"){var o;return(o=JSON.stringify(e))!==null&&o!==void 0?o:""}if(G(e))return"__PROMISE__";if(Array.isArray(e))return`[${e.map((r,a)=>pe(r,t,a.toString()))}]`;if(typeof e.toJSON=="function")return pe(e.toJSON(n),t,n);if(e instanceof Map){const r={};for(const[a,s]of e)r[typeof a=="string"?a:pe(a,t)]=s;return pe(r,t,n)}return e instanceof Set?pe(Array.from(e).sort((r,a)=>pe(r,t).localeCompare(pe(a,t))),t,n):Symbol!==void 0&&e[Symbol.iterator]!=null&&typeof e[Symbol.iterator]=="function"?pe(Array.from(e),t,n):`{${Object.keys(e).filter(r=>e[r]!==void 0).sort().map(r=>`${pe(r,t)}:${pe(e[r],t,r)}`).join(",")}}`}function Bl(e,t={allowFunctions:!1}){return pe(e,t)}var Pt=Bl;const{TreeCache:Pl}=or,dt={equality:"reference",eviction:"keep-all",maxSize:1/0};function Ol({equality:e=dt.equality,eviction:t=dt.eviction,maxSize:n=dt.maxSize}=dt,o){const r=xl(e);return Fl(t,n,r,o)}function xl(e){switch(e){case"reference":return t=>t;case"value":return t=>Pt(t)}throw I(`Unrecognized equality policy ${e}`)}function Fl(e,t,n,o){switch(e){case"keep-all":return new Pl({name:o,mapNodeValue:n});case"lru":return Kn({name:o,maxSize:q(t),mapNodeValue:n});case"most-recent":return Kn({name:o,maxSize:1,mapNodeValue:n})}throw I(`Unrecognized eviction policy ${e}`)}var zl=Ol;function Wl(e){return()=>null}var Gl={startPerfBlock:Wl};const{isLoadable:Kl,loadableWithError:ft,loadableWithPromise:Hl,loadableWithValue:Zt}=rt,{WrappedValue:ar}=nr,{getNodeLoadable:ht,peekNodeLoadable:jl,setNodeValue:ql}=Te,{saveDepsToStore:Zl}=st,{DEFAULT_VALUE:Yl,getConfigDeletionHandler:Xl,getNode:Jl,registerNode:Hn}=ce,{isRecoilValue:Ql}=xe,{markRecoilValueModified:jn}=_e,{retainedByOptionWithDefault:eu}=$e,{recoilCallback:tu}=tr,{startPerfBlock:nu}=Gl;class sr{}const Ye=new sr,Xe=[],vt=new Map,ou=(()=>{let e=0;return()=>e++})();function ir(e){let t=null;const{key:n,get:o,cachePolicy_UNSTABLE:r}=e,a=e.set!=null?e.set:void 0,s=new Set,l=zl(r??{equality:"reference",eviction:"keep-all"},n),u=eu(e.retainedBy_UNSTABLE),f=new Map;let v=0;function _(){return!W("recoil_memory_managament_2020")||v>0}function V(d){return d.getState().knownSelectors.add(n),v++,()=>{v--}}function C(){return Xl(n)!==void 0&&!_()}function y(d,p,S,$,b){Ie(p,$,b),E(d,S)}function E(d,p){le(d,p)&&oe(d),te(p,!0)}function Y(d,p){le(d,p)&&(q(x(d)).stateVersions.clear(),te(p,!1))}function te(d,p){const S=vt.get(d);if(S!=null){for(const $ of S)jn($,q(t));p&&vt.delete(d)}}function w(d,p){let S=vt.get(p);S==null&&vt.set(p,S=new Set),S.add(d)}function B(d,p,S,$,b,D){return p.then(k=>{if(!_())throw oe(d),Ye;const T=Zt(k);return y(d,S,b,T,$),k}).catch(k=>{if(!_())throw oe(d),Ye;if(G(k))return Q(d,k,S,$,b,D);const T=ft(k);throw y(d,S,b,T,$),k})}function Q(d,p,S,$,b,D){return p.then(k=>{if(!_())throw oe(d),Ye;D.loadingDepKey!=null&&D.loadingDepPromise===p?S.atomValues.set(D.loadingDepKey,Zt(k)):d.getState().knownSelectors.forEach(F=>{S.atomValues.delete(F)});const T=X(d,S);if(T&&T.state!=="loading"){if((le(d,b)||x(d)==null)&&E(d,b),T.state==="hasValue")return T.contents;throw T.contents}if(!le(d,b)){const F=me(d,S);if(F!=null)return F.loadingLoadable.contents}const[H,ee]=K(d,S,b);if(H.state!=="loading"&&y(d,S,b,H,ee),H.state==="hasError")throw H.contents;return H.contents}).catch(k=>{if(k instanceof sr)throw Ye;if(!_())throw oe(d),Ye;const T=ft(k);throw y(d,S,b,T,$),k})}function z(d,p,S,$){var b,D,k,T;if(le(d,$)||p.version===((b=d.getState())===null||b===void 0||(D=b.currentTree)===null||D===void 0?void 0:D.version)||p.version===((k=d.getState())===null||k===void 0||(T=k.nextTree)===null||T===void 0?void 0:T.version)){var H,ee,F;Zl(n,S,d,(H=(ee=d.getState())===null||ee===void 0||(F=ee.nextTree)===null||F===void 0?void 0:F.version)!==null&&H!==void 0?H:d.getState().currentTree.version)}for(const J of S)s.add(J)}function K(d,p,S){const $=nu(n);let b=!0,D=!0;const k=()=>{$(),D=!1};let T,H=!1,ee;const F={loadingDepKey:null,loadingDepPromise:null},J=new Map;function he({key:de}){const ue=ht(d,p,de);switch(J.set(de,ue),b||(z(d,p,new Set(J.keys()),S),Y(d,S)),ue.state){case"hasValue":return ue.contents;case"hasError":throw ue.contents;case"loading":throw F.loadingDepKey=de,F.loadingDepPromise=ue.contents,ue.contents}throw I("Invalid Loadable state")}const Ae=de=>(...ue)=>{if(D)throw I("Callbacks from getCallback() should only be called asynchronously after the selector is evalutated.  It can be used for selectors to return objects with callbacks that can work with Recoil state without a subscription.");return t==null&&Qe(!1),tu(d,de,ue,{node:t})};try{T=o({get:he,getCallback:Ae}),T=Ql(T)?he(T):T,Kl(T)&&(T.state==="hasError"&&(H=!0),T=T.contents),G(T)?T=B(d,T,p,J,S,F).finally(k):k(),T=T instanceof ar?T.value:T}catch(de){T=de,G(T)?T=Q(d,T,p,J,S,F).finally(k):(H=!0,k())}return H?ee=ft(T):G(T)?ee=Hl(T):ee=Zt(T),b=!1,Ee(d,S,J),z(d,p,new Set(J.keys()),S),[ee,J]}function X(d,p){let S=p.atomValues.get(n);if(S!=null)return S;const $=new Set;try{S=l.get(D=>(typeof D!="string"&&Qe(!1),ht(d,p,D).contents),{onNodeVisit:D=>{D.type==="branch"&&D.nodeKey!==n&&$.add(D.nodeKey)}})}catch(D){throw I(`Problem with cache lookup for selector "${n}": ${D.message}`)}if(S){var b;p.atomValues.set(n,S),z(d,p,$,(b=x(d))===null||b===void 0?void 0:b.executionID)}return S}function ae(d,p){const S=X(d,p);if(S!=null)return oe(d),S;const $=me(d,p);if($!=null){var b;return((b=$.loadingLoadable)===null||b===void 0?void 0:b.state)==="loading"&&w(d,$.executionID),$.loadingLoadable}const D=ou(),[k,T]=K(d,p,D);return k.state==="loading"?(re(d,D,k,T,p),w(d,D)):(oe(d),Ie(p,k,T)),k}function me(d,p){const S=Co([f.has(d)?[q(f.get(d))]:[],Et(hn(f,([b])=>b!==d),([,b])=>b)]);function $(b){for(const[D,k]of b)if(!ht(d,p,D).is(k))return!0;return!1}for(const b of S){if(b.stateVersions.get(p.version)||!$(b.depValuesDiscoveredSoFarDuringAsyncWork))return b.stateVersions.set(p.version,!0),b;b.stateVersions.set(p.version,!1)}}function x(d){return f.get(d)}function re(d,p,S,$,b){f.set(d,{depValuesDiscoveredSoFarDuringAsyncWork:$,executionID:p,loadingLoadable:S,stateVersions:new Map([[b.version,!0]])})}function Ee(d,p,S){if(le(d,p)){const $=x(d);$!=null&&($.depValuesDiscoveredSoFarDuringAsyncWork=S)}}function oe(d){f.delete(d)}function le(d,p){var S;return p===((S=x(d))===null||S===void 0?void 0:S.executionID)}function Me(d){return Array.from(d.entries()).map(([p,S])=>[p,S.contents])}function Ie(d,p,S){d.atomValues.set(n,p);try{l.set(Me(S),p)}catch($){throw I(`Problem with setting cache for selector "${n}": ${$.message}`)}}function Re(d){if(Xe.includes(n)){const p=`Recoil selector has circular dependencies: ${Xe.slice(Xe.indexOf(n)).join(" → ")}`;return ft(I(p))}Xe.push(n);try{return d()}finally{Xe.pop()}}function Ue(d,p){const S=p.atomValues.get(n);return S??l.get($=>{var b;return typeof $!="string"&&Qe(!1),(b=jl(d,p,$))===null||b===void 0?void 0:b.contents})}function ke(d,p){return Re(()=>ae(d,p))}function P(d){d.atomValues.delete(n)}function O(d,p){t==null&&Qe(!1);for(const $ of s){var S;const b=Jl($);(S=b.clearCache)===null||S===void 0||S.call(b,d,p)}s.clear(),P(p),l.clear(),jn(d,t)}return a!=null?t=Hn({key:n,nodeType:"selector",peek:Ue,get:ke,set:(p,S,$)=>{let b=!1;const D=new Map;function k({key:F}){if(b)throw I("Recoil: Async selector sets are not currently supported.");const J=ht(p,S,F);if(J.state==="hasValue")return J.contents;if(J.state==="loading"){const he=`Getting value of asynchronous atom or selector "${F}" in a pending state while setting selector "${n}" is not yet supported.`;throw I(he)}else throw J.contents}function T(F,J){if(b)throw I("Recoil: Async selector sets are not currently supported.");const he=typeof J=="function"?J(k(F)):J;ql(p,S,F.key,he).forEach((de,ue)=>D.set(ue,de))}function H(F){T(F,Yl)}const ee=a({set:T,get:k,reset:H},$);if(ee!==void 0)throw G(ee)?I("Recoil: Async selector sets are not currently supported."):I("Recoil: selector set should be a void function.");return b=!0,D},init:V,invalidate:P,clearCache:O,shouldDeleteConfigOnRelease:C,dangerouslyAllowMutability:e.dangerouslyAllowMutability,shouldRestoreFromSnapshots:!1,retainedBy:u}):t=Hn({key:n,nodeType:"selector",peek:Ue,get:ke,init:V,invalidate:P,clearCache:O,shouldDeleteConfigOnRelease:C,dangerouslyAllowMutability:e.dangerouslyAllowMutability,shouldRestoreFromSnapshots:!1,retainedBy:u})}ir.value=e=>new ar(e);var We=ir;const{isLoadable:ru,loadableWithError:Yt,loadableWithPromise:Xt,loadableWithValue:Be}=rt,{WrappedValue:cr}=nr,{peekNodeInfo:au}=Te,{DEFAULT_VALUE:Ne,DefaultValue:be,getConfigDeletionHandler:lr,registerNode:su,setConfigDeletionHandler:iu}=ce,{isRecoilValue:cu}=xe,{getRecoilValueAsLoadable:lu,markRecoilValueModified:uu,setRecoilValue:qn,setRecoilValueLoadable:du}=_e,{retainedByOptionWithDefault:fu}=$e,Je=e=>e instanceof cr?e.value:e;function hu(e){const{key:t,persistence_UNSTABLE:n}=e,o=fu(e.retainedBy_UNSTABLE);let r=0;function a(w){return Xt(w.then(B=>(s=Be(B),B)).catch(B=>{throw s=Yt(B),B}))}let s=G(e.default)?a(e.default):ru(e.default)?e.default.state==="loading"?a(e.default.contents):e.default:Be(Je(e.default));s.contents;let l;const u=new Map;function f(w){return w}function v(w,B){const Q=B.then(z=>{var K,X;return((X=((K=w.getState().nextTree)!==null&&K!==void 0?K:w.getState().currentTree).atomValues.get(t))===null||X===void 0?void 0:X.contents)===Q&&qn(w,te,z),z}).catch(z=>{var K,X;throw((X=((K=w.getState().nextTree)!==null&&K!==void 0?K:w.getState().currentTree).atomValues.get(t))===null||X===void 0?void 0:X.contents)===Q&&du(w,te,Yt(z)),z});return Q}function _(w,B,Q){var z;r++;const K=()=>{var x;r--,(x=u.get(w))===null||x===void 0||x.forEach(re=>re()),u.delete(w)};if(w.getState().knownAtoms.add(t),s.state==="loading"){const x=()=>{var re;((re=w.getState().nextTree)!==null&&re!==void 0?re:w.getState().currentTree).atomValues.has(t)||uu(w,te)};s.contents.finally(x)}const X=(z=e.effects)!==null&&z!==void 0?z:e.effects_UNSTABLE;if(X!=null){let le=function(P){if(re&&P.key===t){const O=x;return O instanceof be?V(w,B):G(O)?Xt(O.then(d=>d instanceof be?s.toPromise():d)):Be(O)}return lu(w,P)},Me=function(P){return le(P).toPromise()},Ie=function(P){var O;const d=au(w,(O=w.getState().nextTree)!==null&&O!==void 0?O:w.getState().currentTree,P.key);return re&&P.key===t&&!(x instanceof be)?{...d,isSet:!0,loadable:le(P)}:d},x=Ne,re=!0,Ee=!1,oe=null;const Re=P=>O=>{if(re){const d=le(te),p=d.state==="hasValue"?d.contents:Ne;x=typeof O=="function"?O(p):O,G(x)&&(x=x.then(S=>(oe={effect:P,value:S},S)))}else{if(G(O))throw I("Setting atoms to async values is not implemented.");typeof O!="function"&&(oe={effect:P,value:Je(O)}),qn(w,te,typeof O=="function"?d=>{const p=Je(O(d));return oe={effect:P,value:p},p}:Je(O))}},Ue=P=>()=>Re(P)(Ne),ke=P=>O=>{var d;const{release:p}=w.subscribeToTransactions(S=>{var $;let{currentTree:b,previousTree:D}=S.getState();D||(D=b);const k=($=b.atomValues.get(t))!==null&&$!==void 0?$:s;if(k.state==="hasValue"){var T,H,ee,F;const J=k.contents,he=(T=D.atomValues.get(t))!==null&&T!==void 0?T:s,Ae=he.state==="hasValue"?he.contents:Ne;((H=oe)===null||H===void 0?void 0:H.effect)!==P||((ee=oe)===null||ee===void 0?void 0:ee.value)!==J?O(J,Ae,!b.atomValues.has(t)):((F=oe)===null||F===void 0?void 0:F.effect)===P&&(oe=null)}},t);u.set(w,[...(d=u.get(w))!==null&&d!==void 0?d:[],p])};for(const P of X)try{const O=P({node:te,storeID:w.storeID,parentStoreID_UNSTABLE:w.parentStoreID,trigger:Q,setSelf:Re(P),resetSelf:Ue(P),onSet:ke(P),getPromise:Me,getLoadable:le,getInfo_UNSTABLE:Ie});if(O!=null){var ae;u.set(w,[...(ae=u.get(w))!==null&&ae!==void 0?ae:[],O])}}catch(O){x=O,Ee=!0}if(re=!1,!(x instanceof be)){var me;const P=Ee?Yt(x):G(x)?Xt(v(w,x)):Be(Je(x));P.contents,B.atomValues.set(t,P),(me=w.getState().nextTree)===null||me===void 0||me.atomValues.set(t,P)}}return K}function V(w,B){var Q,z;return(Q=(z=B.atomValues.get(t))!==null&&z!==void 0?z:l)!==null&&Q!==void 0?Q:s}function C(w,B){if(B.atomValues.has(t))return q(B.atomValues.get(t));if(B.nonvalidatedAtoms.has(t)){if(l!=null)return l;if(n==null)return s;const Q=B.nonvalidatedAtoms.get(t),z=n.validator(Q,Ne);return l=z instanceof be?s:Be(z),l}else return s}function y(){l=void 0}function E(w,B,Q){if(B.atomValues.has(t)){const z=q(B.atomValues.get(t));if(z.state==="hasValue"&&Q===z.contents)return new Map}else if(!B.nonvalidatedAtoms.has(t)&&Q instanceof be)return new Map;return l=void 0,new Map().set(t,Be(Q))}function Y(){return lr(t)!==void 0&&r<=0}const te=su({key:t,nodeType:"atom",peek:V,get:C,set:E,init:_,invalidate:y,shouldDeleteConfigOnRelease:Y,dangerouslyAllowMutability:e.dangerouslyAllowMutability,persistence_UNSTABLE:e.persistence_UNSTABLE?{type:e.persistence_UNSTABLE.type,backButton:e.persistence_UNSTABLE.backButton}:void 0,shouldRestoreFromSnapshots:!0,retainedBy:o});return te}function Tn(e){const{...t}=e,n="default"in e?e.default:new Promise(()=>{});return cu(n)?vu({...t,default:n}):hu({...t,default:n})}function vu(e){const t=Tn({...e,default:Ne,persistence_UNSTABLE:e.persistence_UNSTABLE===void 0?void 0:{...e.persistence_UNSTABLE,validator:o=>o instanceof be?o:q(e.persistence_UNSTABLE).validator(o,Ne)},effects:e.effects,effects_UNSTABLE:e.effects_UNSTABLE}),n=We({key:`${e.key}__withFallback`,get:({get:o})=>{const r=o(t);return r instanceof be?e.default:r},set:({set:o},r)=>o(t,r),cachePolicy_UNSTABLE:{eviction:"most-recent"},dangerouslyAllowMutability:e.dangerouslyAllowMutability});return iu(n.key,lr(e.key)),n}Tn.value=e=>new cr(e);var ur=Tn;class pu{constructor(t){var n;M(this,"_map",void 0),M(this,"_keyMapper",void 0),this._map=new Map,this._keyMapper=(n=t==null?void 0:t.mapKey)!==null&&n!==void 0?n:o=>o}size(){return this._map.size}has(t){return this._map.has(this._keyMapper(t))}get(t){return this._map.get(this._keyMapper(t))}set(t,n){this._map.set(this._keyMapper(t),n)}delete(t){this._map.delete(this._keyMapper(t))}clear(){this._map.clear()}}var _u={MapCache:pu},Su=_u.MapCache,mu=Object.freeze({__proto__:null,MapCache:Su});const{LRUCache:Zn}=rr,{MapCache:Ru}=mu,pt={equality:"reference",eviction:"none",maxSize:1/0};function yu({equality:e=pt.equality,eviction:t=pt.eviction,maxSize:n=pt.maxSize}=pt){const o=gu(e);return bu(t,n,o)}function gu(e){switch(e){case"reference":return t=>t;case"value":return t=>Pt(t)}throw I(`Unrecognized equality policy ${e}`)}function bu(e,t,n){switch(e){case"keep-all":return new Ru({mapKey:n});case"lru":return new Zn({mapKey:n,maxSize:q(t)});case"most-recent":return new Zn({mapKey:n,maxSize:1})}throw I(`Unrecognized eviction policy ${e}`)}var dr=yu;const{setConfigDeletionHandler:Tu}=ce;function wu(e){var t,n;const o=dr({equality:(t=(n=e.cachePolicyForParams_UNSTABLE)===null||n===void 0?void 0:n.equality)!==null&&t!==void 0?t:"value",eviction:"keep-all"});return r=>{var a,s;const l=o.get(r);if(l!=null)return l;const{cachePolicyForParams_UNSTABLE:u,...f}=e,v="default"in e?e.default:new Promise(()=>{}),_=ur({...f,key:`${e.key}__${(a=Pt(r))!==null&&a!==void 0?a:"void"}`,default:typeof v=="function"?v(r):v,retainedBy_UNSTABLE:typeof e.retainedBy_UNSTABLE=="function"?e.retainedBy_UNSTABLE(r):e.retainedBy_UNSTABLE,effects:typeof e.effects=="function"?e.effects(r):typeof e.effects_UNSTABLE=="function"?e.effects_UNSTABLE(r):(s=e.effects)!==null&&s!==void 0?s:e.effects_UNSTABLE});return o.set(r,_),Tu(_.key,()=>{o.delete(r)}),_}}var Eu=wu;const{setConfigDeletionHandler:Au}=ce;let Nu=0;function Lu(e){var t,n;const o=dr({equality:(t=(n=e.cachePolicyForParams_UNSTABLE)===null||n===void 0?void 0:n.equality)!==null&&t!==void 0?t:"value",eviction:"keep-all"});return r=>{var a;let s;try{s=o.get(r)}catch(V){throw I(`Problem with cache lookup for selector ${e.key}: ${V.message}`)}if(s!=null)return s;const l=`${e.key}__selectorFamily/${(a=Pt(r,{allowFunctions:!0}))!==null&&a!==void 0?a:"void"}/${Nu++}`,u=V=>e.get(r)(V),f=e.cachePolicy_UNSTABLE,v=typeof e.retainedBy_UNSTABLE=="function"?e.retainedBy_UNSTABLE(r):e.retainedBy_UNSTABLE;let _;if(e.set!=null){const V=e.set;_=We({key:l,get:u,set:(y,E)=>V(r)(y,E),cachePolicy_UNSTABLE:f,dangerouslyAllowMutability:e.dangerouslyAllowMutability,retainedBy_UNSTABLE:v})}else _=We({key:l,get:u,cachePolicy_UNSTABLE:f,dangerouslyAllowMutability:e.dangerouslyAllowMutability,retainedBy_UNSTABLE:v});return o.set(r,_),Au(_.key,()=>{o.delete(r)}),_}}var we=Lu;const Cu=we({key:"__constant",get:e=>()=>e,cachePolicyForParams_UNSTABLE:{equality:"reference"}});function Vu(e){return Cu(e)}var $u=Vu;const Mu=we({key:"__error",get:e=>()=>{throw I(e)},cachePolicyForParams_UNSTABLE:{equality:"reference"}});function Iu(e){return Mu(e)}var Uu=Iu;function ku(e){return e}var Du=ku;const{loadableWithError:fr,loadableWithPromise:hr,loadableWithValue:vr}=rt;function Ot(e,t){const n=Array(t.length).fill(void 0),o=Array(t.length).fill(void 0);for(const[r,a]of t.entries())try{n[r]=e(a)}catch(s){o[r]=s}return[n,o]}function Bu(e){return e!=null&&!G(e)}function xt(e){return Array.isArray(e)?e:Object.getOwnPropertyNames(e).map(t=>e[t])}function sn(e,t){return Array.isArray(e)?t:Object.getOwnPropertyNames(e).reduce((n,o,r)=>({...n,[o]:t[r]}),{})}function Pe(e,t,n){const o=n.map((r,a)=>r==null?vr(t[a]):G(r)?hr(r):fr(r));return sn(e,o)}function Pu(e,t){return t.map((n,o)=>n===void 0?e[o]:n)}const Ou=we({key:"__waitForNone",get:e=>({get:t})=>{const n=xt(e),[o,r]=Ot(t,n);return Pe(e,o,r)},dangerouslyAllowMutability:!0}),xu=we({key:"__waitForAny",get:e=>({get:t})=>{const n=xt(e),[o,r]=Ot(t,n);return r.some(a=>!G(a))?Pe(e,o,r):new Promise(a=>{for(const[s,l]of r.entries())G(l)&&l.then(u=>{o[s]=u,r[s]=void 0,a(Pe(e,o,r))}).catch(u=>{r[s]=u,a(Pe(e,o,r))})})},dangerouslyAllowMutability:!0}),Fu=we({key:"__waitForAll",get:e=>({get:t})=>{const n=xt(e),[o,r]=Ot(t,n);if(r.every(s=>s==null))return sn(e,o);const a=r.find(Bu);if(a!=null)throw a;return Promise.all(r).then(s=>sn(e,Pu(o,s)))},dangerouslyAllowMutability:!0}),zu=we({key:"__waitForAllSettled",get:e=>({get:t})=>{const n=xt(e),[o,r]=Ot(t,n);return r.every(a=>!G(a))?Pe(e,o,r):Promise.all(r.map((a,s)=>G(a)?a.then(l=>{o[s]=l,r[s]=void 0}).catch(l=>{o[s]=void 0,r[s]=l}):null)).then(()=>Pe(e,o,r))},dangerouslyAllowMutability:!0}),Wu=we({key:"__noWait",get:e=>({get:t})=>{try{return We.value(vr(t(e)))}catch(n){return We.value(G(n)?hr(n):fr(n))}},dangerouslyAllowMutability:!0});var Gu={waitForNone:Ou,waitForAny:xu,waitForAll:Fu,waitForAllSettled:zu,noWait:Wu};const{RecoilLoadable:Ku}=rt,{DefaultValue:Hu}=ce,{RecoilRoot:ju,useRecoilStoreID:qu}=ye,{isRecoilValue:Zu}=xe,{retentionZone:Yu}=Nt,{freshSnapshot:Xu}=It,{useRecoilState:Ju,useRecoilState_TRANSITION_SUPPORT_UNSTABLE:Qu,useRecoilStateLoadable:ed,useRecoilValue:td,useRecoilValue_TRANSITION_SUPPORT_UNSTABLE:nd,useRecoilValueLoadable:od,useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE:rd,useResetRecoilState:ad,useSetRecoilState:sd}=_c,{useGotoRecoilSnapshot:id,useRecoilSnapshot:cd,useRecoilTransactionObserver:ld}=Xo,{useRecoilCallback:ud}=tr,{noWait:dd,waitForAll:fd,waitForAllSettled:hd,waitForAny:vd,waitForNone:pd}=Gu;var ge={DefaultValue:Hu,isRecoilValue:Zu,RecoilLoadable:Ku,RecoilEnv:Ge,RecoilRoot:ju,useRecoilStoreID:qu,useRecoilBridgeAcrossReactRoots_UNSTABLE:Wc,atom:ur,selector:We,atomFamily:Eu,selectorFamily:we,constSelector:$u,errorSelector:Uu,readOnlySelector:Du,noWait:dd,waitForNone:pd,waitForAny:vd,waitForAll:fd,waitForAllSettled:hd,useRecoilValue:td,useRecoilValueLoadable:od,useRecoilState:Ju,useRecoilStateLoadable:ed,useSetRecoilState:sd,useResetRecoilState:ad,useGetRecoilValueInfo_UNSTABLE:Bc,useRecoilRefresher_UNSTABLE:ml,useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE:rd,useRecoilValue_TRANSITION_SUPPORT_UNSTABLE:nd,useRecoilState_TRANSITION_SUPPORT_UNSTABLE:Qu,useRecoilCallback:ud,useRecoilTransaction_UNSTABLE:Tl,useGotoRecoilSnapshot:id,useRecoilSnapshot:cd,useRecoilTransactionObserver_UNSTABLE:ld,snapshot_UNSTABLE:Xu,useRetain:mn,retentionZone:Yu},md=ge.DefaultValue,Rd=ge.RecoilRoot,yd=ge.atom,gd=ge.selector,bd=ge.atomFamily,Td=ge.selectorFamily,wd=ge.useRecoilValue,Ed=ge.useRecoilState,Ad=ge.useRecoilCallback;const Nd=(...e)=>e.filter(t=>t).join("/").replace(new RegExp("(?<!:)\\/{2,}"),"/");export{Rd as R,gd as a,wd as b,Ed as c,Ad as d,yd as e,bd as f,Td as g,md as h,Nd as j};
//# sourceMappingURL=http-4b3419c1.js.map

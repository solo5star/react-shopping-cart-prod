{"version":3,"file":"cartItemsState-a1a9cd9c.js","sources":["../../src/api/RestClientResponse.ts","../../src/api/utils/PathGenerator.ts","../../src/api/RestClient.ts","../../src/api/index.ts","../../src/recoil/atoms/authorizationState.ts","../../src/config/servers.ts","../../src/recoil/atoms/serverState.ts","../../src/recoil/atoms/clientState.ts","../../src/recoil/queries/cartItemsQuery.ts","../../src/storages/states/SyncState.ts","../../src/storages/states/SyncCartItemState.ts","../../src/storages/SyncCartItemsStorage.ts","../../src/recoil/storages/remoteCartItemsStorage.ts","../../src/recoil/effects/syncCartItemsEffect.ts","../../src/recoil/atoms/remoteCartItemsState.ts","../../src/recoil/atoms/cartItemsState.ts"],"sourcesContent":["/* eslint-disable no-throw-literal */\nimport type { HttpResponse } from './rest/RestAPI';\n\n// Reference: https://developer.mozilla.org/en-US/docs/Web/HTTP/Status\nconst OK_STATUS_CODES = [\n  200, 201, 202, 203, 204, 205, 206, 207, 208, 226, 300, 301, 302, 303, 304, 307, 308,\n] as const;\n\nclass RestClientResponse<TResponse extends HttpResponse = HttpResponse> {\n  readonly response: TResponse;\n\n  get data() {\n    return this.response.data;\n  }\n\n  get headers() {\n    return this.response.headers;\n  }\n\n  get statusCode() {\n    return this.response.statusCode;\n  }\n\n  constructor(response: TResponse) {\n    this.response = response;\n  }\n\n  private assertStatusCode<StatusCode extends TResponse['statusCode']>(\n    response: TResponse,\n    statusCodes: StatusCode | readonly [StatusCode, ...StatusCode[]],\n  ): response is Extract<TResponse, { statusCode: StatusCode }> {\n    return ((Array.isArray(statusCodes) ? statusCodes : [statusCodes]) as number[]).includes(\n      response.statusCode,\n    );\n  }\n\n  accept<StatusCode extends TResponse['statusCode']>(\n    statusCodes: StatusCode | readonly [StatusCode, ...StatusCode[]],\n  ): Extract<TResponse, { statusCode: StatusCode }> | null {\n    const { response } = this;\n    if (!this.assertStatusCode(response, statusCodes)) {\n      return null;\n    }\n    return response;\n  }\n\n  acceptOrThrow<StatusCode extends TResponse['statusCode']>(\n    statusCodes: StatusCode | readonly [StatusCode, ...StatusCode[]],\n  ): Extract<TResponse, { statusCode: StatusCode }> {\n    const { response } = this;\n    if (!this.assertStatusCode(response, statusCodes)) {\n      throw this;\n    }\n    return response;\n  }\n\n  acceptOkOrThrow() {\n    return this.acceptOrThrow(OK_STATUS_CODES);\n  }\n}\n\nexport default RestClientResponse;\n","import type { ExtractPathFromRestAPI, RestAPI } from '../rest/RestAPI';\nimport type { HttpMethod } from './http';\n\nclass PathGenerator<\n  TRestAPI extends RestAPI,\n  Method extends HttpMethod,\n  Path extends ExtractPathFromRestAPI<TRestAPI, Method>,\n> {\n  private path: Path;\n\n  internalParams: Extract<TRestAPI['request'], { method: Method; path: Path }>['params'];\n\n  internalQueryParams:\n    | Extract<TRestAPI['request'], { method: Method; path: Path }>['queryParams']\n    | null = null;\n\n  constructor(\n    path: Path,\n    ...params: Extract<TRestAPI['request'], { method: Method; path: Path }>['params']\n  ) {\n    this.path = path;\n    this.internalParams = params;\n  }\n\n  queryParams(queryParams: (typeof this)['internalQueryParams']) {\n    this.internalQueryParams = queryParams;\n    return this;\n  }\n\n  toString(): string {\n    const copiedParams = [...this.internalParams];\n    const path = this.path\n      .split('/')\n      .map((pathToken) => (pathToken.startsWith(':') ? copiedParams.shift() : pathToken))\n      .join('/');\n\n    const queryParams =\n      Object.keys(this.internalQueryParams ?? {}).length === 0\n        ? ''\n        : `?${new URLSearchParams(this.internalQueryParams ?? {}).toString()}`;\n\n    return path + queryParams;\n  }\n}\n\nexport default PathGenerator;\n","// eslint-disable-next-line max-classes-per-file\nimport type { Authorization } from '../types/Authorization';\nimport RestClientResponse from './RestClientResponse';\nimport type {\n  ExtractBodyFromRestAPI,\n  ExtractPathFromRestAPI,\n  ExtractResponseFromRestAPI,\n  RestAPI,\n} from './rest/RestAPI';\nimport PathGenerator from './utils/PathGenerator';\nimport type { HttpMethod } from './utils/http';\nimport { joinPath } from './utils/http';\n\ntype RestClientOptions = {\n  base?: string;\n  authorization?: Authorization | null;\n};\n\nclass RestClient<TRestAPI extends RestAPI = RestAPI> {\n  constructor(private readonly options: RestClientOptions = {}) {}\n\n  private getUrl(path: string) {\n    return joinPath(this.options.base ?? '', path);\n  }\n\n  private async parseResponseData(response: Response) {\n    try {\n      return await response.json();\n    } catch {\n      return null;\n    }\n  }\n\n  toJSON() {\n    return this.options;\n  }\n\n  clone(options?: Partial<RestClientOptions>): typeof this {\n    return Object.assign(Object.create(Object.getPrototypeOf(this)), this, {\n      options: {\n        ...this.options,\n        ...options,\n      },\n    });\n  }\n\n  withAuthorization(authorization: Authorization | null) {\n    return this.clone({ authorization });\n  }\n\n  async fetch<\n    Method extends TRestAPI['request']['method'],\n    Path extends TRestAPI['request']['path'],\n  >(\n    method: Method,\n    path: Path | PathGenerator<TRestAPI, 'GET', Path>,\n    fetchInit?: RequestInit,\n  ): Promise<RestClientResponse<ExtractResponseFromRestAPI<TRestAPI, Method, Path>>> {\n    const { authorization } = this.options;\n\n    const response = await fetch(this.getUrl(path.toString()), {\n      method,\n      ...fetchInit,\n      headers: {\n        'Content-Type': 'application/json; charset=UTF-8',\n        ...(authorization\n          ? {\n              Authorization: `Basic ${btoa(`${authorization.username}:${authorization.password}`)}`,\n            }\n          : {}),\n        ...fetchInit?.headers,\n      },\n    });\n\n    return new RestClientResponse({\n      statusCode: response.status,\n      data: await this.parseResponseData(response),\n      headers: Object.fromEntries(response.headers.entries()),\n    });\n  }\n\n  get<Path extends ExtractPathFromRestAPI<TRestAPI, 'GET'>>(\n    path: Path | PathGenerator<TRestAPI, 'GET', Path>,\n    fetchInit?: RequestInit,\n  ) {\n    return this.fetch('GET', path, fetchInit);\n  }\n\n  post<Path extends ExtractPathFromRestAPI<TRestAPI, 'POST'>>(\n    path: Path | PathGenerator<TRestAPI, 'POST', Path>,\n    body: ExtractBodyFromRestAPI<TRestAPI, 'POST', Path>,\n    fetchInit?: RequestInit,\n  ) {\n    return this.fetch('POST', path, {\n      ...fetchInit,\n      headers: {\n        'Content-Type': 'application/json',\n        ...fetchInit?.headers,\n      },\n      body: JSON.stringify(body),\n    });\n  }\n\n  patch<Path extends ExtractPathFromRestAPI<TRestAPI, 'PATCH'>>(\n    path: Path | PathGenerator<TRestAPI, 'PATCH', Path>,\n    body: ExtractBodyFromRestAPI<TRestAPI, 'PATCH', Path>,\n    fetchInit?: RequestInit,\n  ) {\n    return this.fetch('PATCH', path, {\n      headers: {\n        'Content-Type': 'application/json',\n        ...fetchInit?.headers,\n      },\n      body: JSON.stringify(body),\n      ...fetchInit,\n    });\n  }\n\n  delete<Path extends ExtractPathFromRestAPI<TRestAPI, 'DELETE'>>(\n    path: Path | PathGenerator<TRestAPI, 'DELETE', Path>,\n    fetchInit?: RequestInit,\n  ) {\n    return this.fetch('DELETE', path, fetchInit);\n  }\n\n  path<Method extends HttpMethod, Path extends TRestAPI['request']['path']>(\n    path: Path,\n    ...params: Extract<TRestAPI['request'], { method: Method; path: Path }>['params']\n  ) {\n    return new PathGenerator<TRestAPI, Method, Path>(path, ...params);\n  }\n}\n\nexport default RestClient;\n","import RestClient from './RestClient';\nimport type { ShoppingCartRestAPI } from './rest/ShoppingCartRestAPI';\n\nexport class Client extends RestClient<ShoppingCartRestAPI> {}\n","import { atomFamily } from 'recoil';\nimport type { Authorization } from '../../types/Authorization';\nimport type { Server } from '../../types/Server';\n\nconst authorizationState = atomFamily<Authorization | null, Server>({\n  key: 'authorizationState',\n  default: null,\n});\n\nexport default authorizationState;\n","import { joinPath } from '../api/utils/http';\nimport type { Server } from '../types/Server';\nimport { BASE_URL } from './environment';\n\nconst API_URLS: string = import.meta.env.VITE_API_URLS;\n\nconst parseAPIUrl = (apiUrl: string): Server => {\n  const matches = /^(?:\\[(?<name>[가-힣\\w\\d_-]+)\\])?(?<base>(?<protocol>https?:\\/\\/)?.+)$/.exec(\n    apiUrl,\n  );\n  if (matches === null || matches.groups === undefined)\n    throw new Error(\n      `\"${apiUrl}\"은 올바르지 않은 API_URL입니다. \"[name]주소\" 형식으로 입력해야 합니다.`,\n    );\n\n  const { name, base, protocol } = matches.groups;\n  if (!base) {\n    throw new Error(`\"${base}\"은 올바르지 않은 URL입니다.`);\n  }\n\n  return {\n    name,\n    base: protocol ? base : joinPath(BASE_URL, base),\n  };\n};\n\nconst servers: Server[] = API_URLS.split(',').map(parseAPIUrl);\n\nexport default servers;\n","import { atom } from 'recoil';\nimport servers from '../../config/servers';\nimport type { Server } from '../../types/Server';\n\nconst serverState = atom<Server>({\n  key: 'serverState',\n  default: servers[0],\n});\n\nexport default serverState;\n","import { selector } from 'recoil';\nimport { Client } from '../../api';\nimport authorizationState from './authorizationState';\nimport serverState from './serverState';\n\nconst clientState = selector({\n  key: 'clientState',\n  get: ({ get }) => {\n    const server = get(serverState);\n    const authorization = get(authorizationState(server));\n\n    const client = new Client({\n      base: server.base,\n      authorization,\n    });\n\n    return client;\n  },\n});\n\nexport default clientState;\n","import { selectorFamily } from 'recoil';\nimport type { Client } from '../../api';\n\ntype CartItemQueryParams = {\n  client: Client;\n};\n\nconst cartItemsQuery = selectorFamily({\n  key: 'cartItemsQuery',\n  get:\n    ({ client }: CartItemQueryParams) =>\n    () =>\n      client.get('/cart-items'),\n});\n\nexport default cartItemsQuery;\n","/* eslint-disable no-await-in-loop */\nimport type RestClient from '../../api/RestClient';\n\ntype BaseState = object | number | string | null | undefined;\n\ntype SetOrUpdate<State> = State | ((state: State) => State);\n\ntype ErrorHandler = () => void;\n\ntype ConflictHandler<ClientState extends BaseState, RemoteState extends BaseState> = (\n  corruptedState: ClientState,\n  expectedState: RemoteState,\n) => void;\n\n/**\n * client와 remote의 상태를 동기화할 때 사용하는 상태입니다.\n *\n * client side에서 상태가 자주 변경됨을 가정하고 설계하였기 때문에\n * 낙관적 업데이트(Optimistic update)에 적합합니다.\n *\n * @example\n * const client = new Client();\n * const syncState = new SyncState<Client, { count: number }>(client, { count: 1 });\n * syncState.set({ count: 2 });\n * syncState.set({ count: 3 });\n */\nexport abstract class SyncState<\n  Client extends RestClient,\n  ClientState extends BaseState,\n  RemoteState extends BaseState,\n> {\n  readonly client: Client;\n\n  /**\n   * dirtyUpdates는 remote에 동기화해야 하는 업데이트 조각(이하 update)들입니다.\n   * 예를 들어, remote의 상태가 3이고, 사용자가 count를 4, 5, 6 으로 바꾸었다면,\n   * dirtyUpdates는 [4, 5, 6] 이 됩니다.\n   */\n  protected dirtyUpdates: SetOrUpdate<ClientState>[] = [];\n\n  clientState: ClientState;\n\n  /**\n   * remote와 동기화 된 상태입니다. 이 상태는 remote와 동일함을 보장합니다.\n   */\n  remoteState: RemoteState;\n\n  /**\n   * client -> remote 로 동기화하는 비동기 작업입니다.\n   */\n  protected upstreamSync: Promise<RemoteState> | null = null;\n\n  /**\n   * client <- remote 로 동기화하는 비동기 작업입니다.\n   */\n  protected downstreamSync: Promise<RemoteState> | null = null;\n\n  protected errorHandler: ErrorHandler | null = null;\n\n  protected conflictHandler: ConflictHandler<ClientState, RemoteState> | null = null;\n\n  /**\n   * @param client 비동기 통신에 필요한 API Client 구현체입니다.\n   * @param clientState 현재 client의 상태입니다.\n   * @param remoteState 현재 remote의 상태를 주어야 합니다. 이 값을 기준으로 동기화를 시작합니다.\n   */\n  constructor(client: Client, clientState: ClientState, remoteState: RemoteState) {\n    this.client = client;\n    this.clientState = clientState;\n    this.remoteState = remoteState;\n  }\n\n  /**\n   * 상태 업데이트를 추가합니다. 현재 진행중인 동기화 작업이 없다면 즉시 수행됩니다.\n   */\n  set(state: SetOrUpdate<ClientState>) {\n    this.dirtyUpdates.push(state);\n    this.flushDirtyUpdates();\n  }\n\n  hasDirtyUpdate() {\n    return this.dirtyUpdates.length > 0;\n  }\n\n  isSynchronizing() {\n    return this.upstreamSync || this.downstreamSync;\n  }\n\n  /**\n   * 동기화 작업이 모두 끝날 때 까지 대기할 수 있는 함수입니다.\n   */\n  async waitForSync() {\n    while (this.upstreamSync || this.downstreamSync) {\n      await this.upstreamSync;\n      await this.downstreamSync;\n    }\n  }\n\n  /**\n   * remote -> client로 동기화 할 작업을 추가합니다.\n   */\n  enqueueDownstreamSync(sync: Promise<RemoteState> | RemoteState) {\n    this.dirtyUpdates = [];\n\n    if (sync instanceof Promise) {\n      this.downstreamSync = sync;\n      this.downstreamSync.then((remoteState) => {\n        this.downstreamSync = null;\n        this.remoteState = remoteState;\n        this.flushDirtyUpdates();\n      });\n      return;\n    }\n    this.remoteState = sync;\n  }\n\n  /**\n   * client -> remote로 동기화 할 작업을 추가합니다.\n   *\n   * {@link sync} 는 resolve된 값으로 반드시 remote에서 응답한 상태여야 합니다.\n   * 만약 remote에서 받아온 상태가 client와 일치하지 않을 시\n   * {@link conflictHandler} 함수를 invoke합니다.\n   */\n  protected enqueueUpstreamSync(sync: Promise<RemoteState>, expectedState: ClientState) {\n    this.upstreamSync = sync;\n    this.upstreamSync.then((synchronizedState) => {\n      this.remoteState = synchronizedState;\n      this.upstreamSync = null;\n      if (!this.stateEquals(expectedState, this.remoteState)) {\n        this.conflictHandler?.(expectedState, this.remoteState);\n      }\n      this.flushDirtyUpdates();\n    });\n  }\n\n  /**\n   * remote에 동기화해야 하는 update들을 remote에 전송합니다.\n   *\n   * 동기화 작업은 동시에 한 번만 수행됩니다.\n   */\n  flushDirtyUpdates() {\n    if (!this.hasDirtyUpdate()) return; // 업데이트 할 사항이 없다면 리턴합니다.\n    if (this.isSynchronizing()) return; // 이미 upstreamSync 혹은 downstreamSync가 수행중이라면 종료된 후 dirtyUpdate를 진행합니다.\n\n    const lastClientState = (this.dirtyUpdates ?? []).reduce<ClientState>(\n      (accumulatedState, update) => {\n        if (typeof update === 'function') {\n          return update(accumulatedState);\n        }\n        return update;\n      },\n      this.clientState,\n    );\n    this.dirtyUpdates = [];\n    this.clientState = structuredClone(lastClientState);\n\n    const sync = this.syncToRemote();\n    if (sync === null) return;\n\n    this.enqueueUpstreamSync(sync, lastClientState);\n  }\n\n  /**\n   * 상태 동등성 비교 함수입니다.\n   *\n   * {@link enqueueUpstreamSync} 에서 예상했던 상태와 동일한지 확인하기 위해 사용합니다.\n   */\n  abstract stateEquals(clientState: ClientState, remoteState: RemoteState): boolean;\n\n  /**\n   * dirtyUpdates를 lastState로 취합한 후, 이를 client -> remote로 동기화하는\n   * 작업을 수행합니다.\n   *\n   * 이 함수는 동기화 작업(`Promise<State>`)을 반환해야 합니다.\n   * 동기화 작업이 완료되면 완료된 값이 {@link remoteState} 가 됩니다.\n   *\n   * 만약 아무것도 하지 않아도 된다면 `null`을 반환합니다.\n   *\n   * @example\n   * syncToRemote(): Promise<RemoteState> | null {\n   *   if (this.remoteState.count === this.clientState.count) {\n   *     return null; // up to date, no-op\n   *   }\n   *   return this.client.post('/count', { count: lastState.count })\n   *     .acceptOrThrow(200).then((response) => ({ count: response.data.count }));\n   * }\n   */\n  abstract syncToRemote(): Promise<RemoteState> | null;\n\n  /**\n   * 동기화 중 오류가 발생했을 시의 동작을 지정합니다.\n   */\n  onError(errorHandler: ErrorHandler | null) {\n    this.errorHandler = errorHandler;\n  }\n\n  /**\n   * client -> remote로 상태를 전송하였으나 remote에서 응답한 상태가\n   * client와 일치하지 않는 경우의 동작을 지정합니다.\n   */\n  onConflict(conflictHandler: ConflictHandler<ClientState, RemoteState> | null) {\n    this.conflictHandler = conflictHandler;\n  }\n\n  clear() {\n    this.errorHandler = null;\n    this.conflictHandler = null;\n  }\n}\n\nexport default SyncState;\n","import type { Client } from '../../api';\nimport type { CartItemEntity } from '../../api/rest/ShoppingCartRestAPI';\nimport type { CartItem } from '../../types/CartItem';\nimport type { Product } from '../../types/Product';\nimport { SyncState } from './SyncState';\n\ntype ClientState = CartItem | null;\n\ntype RemoteState = CartItemEntity | null;\n\nclass SyncCartItemState extends SyncState<Client, ClientState, RemoteState> {\n  readonly productId: Product['id'];\n\n  constructor(\n    productId: Product['id'],\n    client: Client,\n    clientState: ClientState,\n    remoteState: RemoteState,\n  ) {\n    super(client, clientState, remoteState);\n    this.productId = productId;\n  }\n\n  override stateEquals(clientState: ClientState, remoteState: RemoteState): boolean {\n    return (\n      clientState?.checked === remoteState?.checked &&\n      clientState?.quantity === remoteState?.quantity\n    );\n  }\n\n  override syncToRemote(): Promise<RemoteState> | null {\n    // sync: delete\n    // 최종적으로 설정될 상태가 null(삭제됨)이라면, 삭제 쿼리를 보냅니다.\n    if (this.clientState === null) {\n      if (this.remoteState !== null) {\n        return this.client\n          .delete(this.client.path('/cart-items/:cartItemId', this.remoteState.id))\n          .then((response) => response.acceptOrThrow(204))\n          .then(() => null);\n      }\n      return null;\n    }\n\n    // sync: create\n    // id가 존재하지 않는다면 생성하는 쿼리를 보냅니다.\n    const { product } = this.clientState;\n    if (this.remoteState === null) {\n      // id가 없어 lastState를 업데이트할 수 없기 때문에, 우선은 생성을 먼저 하고 나중에 lastState로 설정\n      return this.client\n        .post('/cart-items', { productId: product.id })\n        .then((response) => response.acceptOrThrow(201))\n        .then((response) => {\n          // 변경한 상태가 없었다면 원래 설정하려고 했던 상태로 설정\n          // if (!this.hasDirtyUpdate()) this.set(lastState);\n\n          const id = Number(response.headers.location.split('/').pop());\n          return { id, product, ...response.data };\n        });\n    }\n\n    // sync: optimize update\n    // remote와 동일한 값이라면 업데이트할 필요가 없습니다.\n    if (\n      this.remoteState.checked === this.clientState.checked &&\n      this.remoteState.quantity === this.clientState.quantity\n    ) {\n      return null;\n    }\n\n    // sync: update\n    // 삭제 혹은 생성이 아닐 경우 값을 업데이트하는 쿼리를 보냅니다.\n    const { id } = this.remoteState;\n    return this.client\n      .patch(this.client.path('/cart-items/:cartItemId', id), {\n        quantity: this.clientState.quantity,\n        checked: this.clientState.checked,\n      })\n      .then((response) => response.acceptOrThrow(200))\n      .then((response) => ({ id, product, ...response.data }));\n  }\n}\n\nexport default SyncCartItemState;\n","/* eslint-disable no-await-in-loop */\nimport type { Client } from '../api';\nimport type { CartItemEntity } from '../api/rest/ShoppingCartRestAPI';\nimport type { CartItem } from '../types/CartItem';\nimport SyncCartItemState from './states/SyncCartItemState';\n\nconst DEFAULT_SYNC_INTERVAL = 30_000;\n\ntype ChangeByDownstreamHandler = (updater: (cartItems: CartItem[]) => CartItem[]) => void;\n\ntype SyncHandler = (\n  info: { isSynchronizing: true } | { cartItems: CartItemEntity[]; isSynchronizing: false },\n) => void;\n\ntype SyncCartItemsStorageOptions = {\n  /**\n   * remote로 부터 데이터를 받아 동기화하는 간격을 설정합니다. 단위: ms\n   */\n  syncInterval: number;\n};\n\nclass SyncCartItemsStorage {\n  protected readonly options: SyncCartItemsStorageOptions;\n\n  protected readonly client: Client;\n\n  protected readonly syncStates: Map<CartItem['product']['id'], SyncCartItemState> = new Map();\n\n  protected syncIntervalHandler: NodeJS.Timer;\n\n  protected changeByDownstreamHandler: ChangeByDownstreamHandler | null = null;\n\n  protected syncHandler: SyncHandler | null = null;\n\n  protected sync: Promise<CartItemEntity[]> | null = null;\n\n  constructor(\n    client: Client,\n    options: SyncCartItemsStorageOptions = {\n      syncInterval: DEFAULT_SYNC_INTERVAL,\n    },\n  ) {\n    this.options = options;\n    this.client = client;\n\n    this.syncIntervalHandler = setInterval(\n      () => this.doDownstreamSync(),\n      this.options.syncInterval,\n    );\n  }\n\n  /**\n   * remote에서 받아온 상태를 토대로 동기화를 시작하기 위해 이 함수를 호출합니다.\n   */\n  setFromRemote(cartItems: CartItemEntity[]) {\n    cartItems.forEach((cartItem) => {\n      const state = this.createState(cartItem.product.id, cartItem, cartItem);\n      state.set(cartItem); // HACK: force trigger sync\n    });\n\n    this.fireSyncEvent(cartItems);\n  }\n\n  private createState(\n    productId: CartItem['product']['id'],\n    clientCartItem?: CartItem,\n    remoteCartItem?: CartItemEntity,\n  ) {\n    const state = new SyncCartItemState(\n      productId,\n      this.client,\n      clientCartItem ?? null,\n      remoteCartItem ?? null,\n    );\n    this.syncStates.set(productId, state);\n    state.onError(() => this.doDownstreamSync());\n    state.onConflict((clientCartItem, remoteCartItem) => {\n      this.resolveConflict(productId, remoteCartItem);\n    });\n    return state;\n  }\n\n  private resolveConflict(productId: CartItem['product']['id'], expectedCartItem: CartItem | null) {\n    this.changeByDownstreamHandler?.((cartItems) => {\n      // correction: deleted\n      if (expectedCartItem === null) {\n        return cartItems.filter((cartItem) => cartItem.product.id !== productId);\n      }\n\n      // correction: different value\n      return cartItems.map((cartItem) => {\n        if (cartItem.product.id !== productId) return cartItem;\n\n        return { ...cartItem, expectedCartItem };\n      });\n    });\n  }\n\n  /**\n   * client의 상태가 변경되었을 때 remote에 상태 변경을 통보하기 위해 호출하는 함수입니다.\n   */\n  setFromClient(cartItems: CartItem[]) {\n    this.syncStates.forEach((state, productId) => {\n      const isRemoved = !cartItems.some((cartItem) => cartItem.product.id === productId);\n\n      if (isRemoved) state.set(null);\n    });\n\n    cartItems.forEach((cartItem) => {\n      const state = this.syncStates.get(cartItem.product.id);\n      if (state) {\n        state.set(cartItem);\n        return;\n      }\n      const stateCreated = this.createState(cartItem.product.id);\n      stateCreated.set(cartItem);\n      this.syncStates.set(cartItem.product.id, stateCreated);\n    });\n\n    this.fireSyncEvent(cartItems);\n  }\n\n  /**\n   * client <-> remote 간 상태 동기화가 시작되었을 때,\n   * 상태 동기화가 끝난 후 {@link synchronizedHandler}를 호출합니다.\n   */\n  private async fireSyncEvent(cartItems: CartItem[]) {\n    if (this.sync === null) {\n      this.syncHandler?.({ isSynchronizing: true });\n      this.sync = this.waitForSync().then(() => {\n        return cartItems\n          .map((cartItem) => this.syncStates.get(cartItem.product.id)?.remoteState)\n          .filter((cartItem): cartItem is CartItemEntity => Boolean(cartItem));\n      });\n      this.sync.then((cartItems) => {\n        this.syncHandler?.({ cartItems, isSynchronizing: false });\n        this.sync = null;\n      });\n    }\n  }\n\n  reset() {\n    this.syncStates.forEach((state) => {\n      state.set(null);\n      state.clear();\n    });\n    // this.states.clear();\n  }\n\n  /**\n   * remote로 부터 최신 상태를 받아와 client의 상태를 동기화합니다.\n   */\n  async doDownstreamSync() {\n    const cartItems = await this.client\n      .get('/cart-items')\n      .then((response) => response.acceptOrThrow(200).data);\n\n    this.syncStates.forEach((state) =>\n      state.enqueueDownstreamSync(\n        cartItems.find((cartItem) => cartItem.product.id === state.productId) ?? null,\n      ),\n    );\n    this.changeByDownstreamHandler?.(() => cartItems);\n  }\n\n  async waitForSync() {\n    while ([...this.syncStates.values()].some((state) => state.isSynchronizing())) {\n      await Promise.all(\n        [...this.syncStates.values()]\n          .filter((state) => state.isSynchronizing())\n          .map((state) => state.waitForSync()),\n      );\n    }\n  }\n\n  clear() {\n    clearInterval(this.syncIntervalHandler);\n    this.syncStates.clear();\n  }\n\n  /**\n   * 예외 상황의 발생으로 인해 client의 상태가 수정되어야 할 때 호출되는 핸들러입니다.\n   */\n  onChangeByDownstream(changeByDownstreamHandler: ChangeByDownstreamHandler | null) {\n    this.changeByDownstreamHandler = changeByDownstreamHandler;\n  }\n\n  /**\n   * 상태가 remote와 동기화를 시작할 때 혹은 완료되었을 때 호출됩니다.\n   */\n  onSync(syncHandler: SyncHandler | null) {\n    this.syncHandler = syncHandler;\n  }\n}\n\nexport default SyncCartItemsStorage;\n","import { atomFamily } from 'recoil';\nimport type { Client } from '../../api';\nimport SyncCartItemsStorage from '../../storages/SyncCartItemsStorage';\n\nconst remoteCartItemsStorage = atomFamily<SyncCartItemsStorage, Client>({\n  key: 'remoteCartItemsStorageState',\n  default: (client) => new SyncCartItemsStorage(client),\n  dangerouslyAllowMutability: true,\n});\n\nexport default remoteCartItemsStorage;\n","import type { AtomEffect } from 'recoil';\nimport { DefaultValue } from 'recoil';\nimport type { Client } from '../../api';\nimport type { CartItem } from '../../types/CartItem';\nimport cartItemsQuery from '../queries/cartItemsQuery';\nimport remoteCartItemsStorage from '../storages/remoteCartItemsStorage';\n\n/**\n * cartItems를 remote와 동기화하는 AtomEffect입니다.\n */\nconst syncCartItemsEffect = (client: Client): AtomEffect<CartItem[]> => {\n  return ({ onSet, setSelf, getPromise }) => {\n    const willStorage = getPromise(remoteCartItemsStorage(client));\n\n    willStorage.then((storage) => {\n      storage.onChangeByDownstream((updater) =>\n        setSelf((cartItems) => {\n          if (cartItems instanceof DefaultValue) return cartItems;\n\n          return updater(cartItems);\n        }),\n      );\n    });\n\n    getPromise(cartItemsQuery({ client })).then((response) => {\n      const cartItems = response.acceptOrThrow(200).data;\n      willStorage.then((storage) => {\n        storage.setFromRemote(cartItems);\n      });\n    });\n\n    onSet((newCartItems, oldCartItems, isReset) => {\n      if (isReset) {\n        willStorage.then((storage) => storage.reset());\n        return;\n      }\n      willStorage.then((storage) => storage.setFromClient(newCartItems));\n    });\n\n    return () => willStorage.then((storage) => storage.clear());\n  };\n};\n\nexport default syncCartItemsEffect;\n","import { DefaultValue, atomFamily, selectorFamily } from 'recoil';\nimport type { Client } from '../../api';\nimport type { CartItemEntity } from '../../api/rest/ShoppingCartRestAPI';\nimport cartItemsQuery from '../queries/cartItemsQuery';\nimport remoteCartItemsStorage from '../storages/remoteCartItemsStorage';\n\ntype RemoteCartItemsState = {\n  cartItems: CartItemEntity[];\n  isSynchronizing: boolean;\n};\n\nconst remoteCartItemsState = atomFamily<RemoteCartItemsState, Client>({\n  key: 'remoteCartItemsState',\n  default: selectorFamily({\n    key: 'remoteCartItemsState/default',\n    get:\n      (client) =>\n      ({ get }) => {\n        const response = get(cartItemsQuery({ client }));\n\n        return {\n          isSynchronizing: false,\n          cartItems: response.acceptOrThrow(200).data,\n        };\n      },\n  }),\n  effects: (client) => [\n    ({ setSelf, getPromise }) => {\n      const willStorage = getPromise(remoteCartItemsStorage(client));\n\n      willStorage.then((storage) => {\n        storage.onSync((info) => {\n          setSelf((syncStatus) => {\n            if (syncStatus instanceof DefaultValue) {\n              if (info.isSynchronizing) return syncStatus;\n\n              return { cartItems: info.cartItems, isSynchronizing: info.isSynchronizing };\n            }\n\n            return {\n              cartItems: syncStatus.cartItems,\n              ...info,\n            };\n          });\n          console.log(info.isSynchronizing ? 'synchronizing ...' : 'synchronized');\n        });\n      });\n    },\n  ],\n});\n\nexport default remoteCartItemsState;\n","/* eslint-disable no-nested-ternary */\nimport { atomFamily, DefaultValue, selectorFamily } from 'recoil';\nimport type { Client } from '../../api';\nimport type { CartItem } from '../../types/CartItem';\nimport syncCartItemsEffect from '../effects/syncCartItemsEffect';\nimport cartItemsQuery from '../queries/cartItemsQuery';\nimport remoteCartItemsState from './remoteCartItemsState';\n\nconst internalCartItemsState = atomFamily<CartItem[], Client>({\n  key: 'internalCartItemsState',\n  default: selectorFamily({\n    key: 'internalCartItemsState/default',\n    get:\n      (client: Client) =>\n      ({ get }) => {\n        const response = get(cartItemsQuery({ client }));\n        return response.acceptOrThrow(200).data;\n      },\n  }),\n  effects: (client) => [syncCartItemsEffect(client)],\n});\n\nconst cartItemsState = selectorFamily<CartItem[], Client>({\n  key: 'cartItemsState',\n  get:\n    (client) =>\n    ({ get }) => {\n      const cartItems = get(internalCartItemsState(client));\n      const remoteCartItems = get(remoteCartItemsState(client));\n      return cartItems;\n    },\n  set:\n    (client) =>\n    ({ set, reset }, rawNewCartItems) => {\n      if (rawNewCartItems instanceof DefaultValue) {\n        reset(internalCartItemsState(client));\n        return;\n      }\n\n      const newCartItems = rawNewCartItems.filter((newCartItem) => newCartItem.quantity > 0);\n      set(internalCartItemsState(client), newCartItems);\n    },\n});\n\nexport default cartItemsState;\n"],"names":["OK_STATUS_CODES","RestClientResponse","response","statusCodes","PathGenerator","path","params","queryParams","copiedParams","pathToken","RestClient","options","joinPath","authorization","method","fetchInit","body","Client","authorizationState","atomFamily","API_URLS","parseAPIUrl","apiUrl","matches","name","base","protocol","BASE_URL","servers","serverState","atom","clientState","selector","get","server","cartItemsQuery","selectorFamily","client","SyncState","remoteState","state","sync","expectedState","synchronizedState","_a","lastClientState","accumulatedState","update","errorHandler","conflictHandler","SyncCartItemState","productId","product","id","DEFAULT_SYNC_INTERVAL","SyncCartItemsStorage","cartItems","cartItem","clientCartItem","remoteCartItem","expectedCartItem","stateCreated","changeByDownstreamHandler","syncHandler","remoteCartItemsStorage","syncCartItemsEffect","onSet","setSelf","getPromise","willStorage","storage","updater","DefaultValue","newCartItems","oldCartItems","isReset","remoteCartItemsState","info","syncStatus","internalCartItemsState","cartItemsState","set","reset","rawNewCartItems","newCartItem"],"mappings":"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"}